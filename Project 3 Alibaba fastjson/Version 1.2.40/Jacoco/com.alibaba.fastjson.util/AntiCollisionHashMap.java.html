<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AntiCollisionHashMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fastjson</a> &gt; <a href="index.source.html" class="el_package">com.alibaba.fastjson.util</a> &gt; <span class="el_source">AntiCollisionHashMap.java</span></div><h1>AntiCollisionHashMap.java</h1><pre class="source lang-java linenums">package com.alibaba.fastjson.util;

import java.io.IOException;
import java.io.Serializable;
import java.util.*;

/**
 * @deprecated
 */
public class AntiCollisionHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements
        Map&lt;K, V&gt;, Cloneable, Serializable {

<span class="nc" id="L13">    transient volatile Set&lt;K&gt; keySet = null;</span>
<span class="nc" id="L14">    transient volatile Collection&lt;V&gt; values = null;</span>

    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 16;

    /**
     * The maximum capacity, used if a higher value is implicitly specified by
     * either of the constructors with arguments. MUST be a power of two &lt;=
     * 1&lt;&lt;30.
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    /**
     * The table, resized as necessary. Length MUST Always be a power of two.
     */
    transient Entry&lt;K, V&gt;[] table;

    /**
     * The number of key-value mappings contained in this map.
     */
    transient int size;

    /**
     * The next size value at which to resize (capacity * load factor).
     *
     * @serial
     */
    int threshold;

    /**
     * The load factor for the hash table.
     *
     * @serial
     */
    final float loadFactor;

    /**
     * The number of times this SafelyHashMap has been structurally modified
     * Structural modifications are those that change the number of mappings in
     * the SafelyHashMap or otherwise modify its internal structure (e.g.,
     * rehash). This field is used to make iterators on Collection-views of the
     * SafelyHashMap fail-fast. (See ConcurrentModificationException).
     */
    transient volatile int modCount;

    /**
     * Constructs an empty &lt;tt&gt;SafelyHashMap&lt;/tt&gt; with the specified initial
     * capacity and load factor.
     *
     * @param initialCapacity
     *            the initial capacity
     * @param loadFactor
     *            the load factor
     * @throws IllegalArgumentException
     *             if the initial capacity is negative or the load factor is
     *             nonpositive
     */

    final static int M_MASK = 0x8765fed3;
    final static int SEED = -2128831035;
    final static int KEY = 16777619;

<span class="nc" id="L83">    final int random = new Random().nextInt(99999); // a fixed value in an instance</span>
    private int hashString(String key) {

<span class="nc" id="L86">        int hash = SEED * random;</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        for (int i = 0; i &lt; key.length(); i++)</span>
<span class="nc" id="L88">            hash = (hash * KEY) ^ key.charAt(i);</span>
<span class="nc" id="L89">        return (hash ^ (hash &gt;&gt; 1)) &amp; M_MASK;</span>
    }

<span class="nc" id="L92">    public AntiCollisionHashMap(int initialCapacity, float loadFactor) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (initialCapacity &lt; 0)</span>
<span class="nc" id="L94">            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;</span>
                    + initialCapacity);
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="nc" id="L97">            initialCapacity = MAXIMUM_CAPACITY;</span>
<span class="nc bnc" id="L98" title="All 4 branches missed.">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span>
<span class="nc" id="L99">            throw new IllegalArgumentException(&quot;Illegal load factor: &quot;</span>
                    + loadFactor);

        // Find a power of 2 &gt;= initialCapacity
<span class="nc" id="L103">        int capacity = 1;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        while (capacity &lt; initialCapacity)</span>
<span class="nc" id="L105">            capacity &lt;&lt;= 1;</span>

<span class="nc" id="L107">        this.loadFactor = loadFactor;</span>
<span class="nc" id="L108">        threshold = (int) (capacity * loadFactor);</span>
<span class="nc" id="L109">        table = new Entry[capacity];</span>
<span class="nc" id="L110">        init();</span>
<span class="nc" id="L111">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;SafelyHashMap&lt;/tt&gt; with the specified initial
     * capacity and the default load factor (0.75).
     *
     * @param initialCapacity
     *            the initial capacity.
     * @throws IllegalArgumentException
     *             if the initial capacity is negative.
     */
    public AntiCollisionHashMap(int initialCapacity) {
<span class="nc" id="L123">        this(initialCapacity, DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L124">    }</span>

    /**
     * Constructs an empty &lt;tt&gt;SafelyHashMap&lt;/tt&gt; with the default initial
     * capacity (16) and the default load factor (0.75).
     */
<span class="nc" id="L130">    public AntiCollisionHashMap() {</span>
<span class="nc" id="L131">        this.loadFactor = DEFAULT_LOAD_FACTOR;</span>
<span class="nc" id="L132">        threshold = (int) (DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span>
<span class="nc" id="L133">        table = new Entry[DEFAULT_INITIAL_CAPACITY];</span>
<span class="nc" id="L134">        init();</span>
<span class="nc" id="L135">    }</span>

    /**
     * Constructs a new &lt;tt&gt;SafelyHashMap&lt;/tt&gt; with the same mappings as the
     * specified &lt;tt&gt;Map&lt;/tt&gt;. The &lt;tt&gt;SafelyHashMap&lt;/tt&gt; is created with
     * default load factor (0.75) and an initial capacity sufficient to hold the
     * mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.
     *
     * @param m
     *            the map whose mappings are to be placed in this map
     * @throws NullPointerException
     *             if the specified map is null
     */
    public AntiCollisionHashMap(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L149">        this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,</span>
                DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
<span class="nc" id="L151">        putAllForCreate(m);</span>
<span class="nc" id="L152">    }</span>

    // internal utilities

    /**
     * Initialization hook for subclasses. This method is called in all
     * constructors and pseudo-constructors (clone, readObject) after
     * SafelyHashMap has been initialized but before any entries have been
     * inserted. (In the absence of this method, readObject would require
     * explicit knowledge of subclasses.)
     */
    void init() {
<span class="nc" id="L164">    }</span>

    /**
     * Applies a supplemental hash function to a given hashCode, which defends
     * against poor quality hash functions. This is critical because
     * SafelyHashMap uses power-of-two length hash tables, that otherwise
     * encounter collisions for hashCodes that do not differ in lower bits.
     * Note: Null keys always map to hash 0, thus index 0.
     */
    static int hash(int h) {
        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
<span class="nc" id="L177">        h = h * h;</span>
<span class="nc" id="L178">        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</span>
<span class="nc" id="L179">        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</span>
    }

    /**
     * Returns index for hash code h.
     */
    static int indexFor(int h, int length) {
<span class="nc" id="L186">        return h &amp; (length - 1);</span>
    }

    /**
     * Returns the number of key-value mappings in this map.
     *
     * @return the number of key-value mappings in this map
     */
    public int size() {
<span class="nc" id="L195">        return size;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.
     *
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings
     */
    public boolean isEmpty() {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        return size == 0;</span>
    }

    /**
     * Returns the value to which the specified key is mapped, or {@code null}
     * if this map contains no mapping for the key.
     *
     * &lt;p&gt;
     * More formally, if this map contains a mapping from a key {@code k} to a
     * value {@code v} such that {@code (key==null ? k==null :
     * key.equals(k))}, then this method returns {@code v}; otherwise it returns
     * {@code null}. (There can be at most one such mapping.)
     *
     * &lt;p&gt;
     * A return value of {@code null} does not &lt;i&gt;necessarily&lt;/i&gt; indicate that
     * the map contains no mapping for the key; it's also possible that the map
     * explicitly maps the key to {@code null}. The {@link #containsKey
     * containsKey} operation may be used to distinguish these two cases.
     *
     * @see #put(Object, Object)
     */
    public V get(Object key) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L227">            return getForNullKey();</span>
<span class="nc" id="L228">        int hash = 0;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (key instanceof String)</span>
<span class="nc" id="L230">            hash = hash(hashString((String) key));</span>
        else
<span class="nc" id="L232">            hash = hash(key.hashCode());</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {</span>
            Object k;
<span class="nc bnc" id="L235" title="All 6 branches missed.">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span>
<span class="nc" id="L236">                return e.value;</span>
        }
<span class="nc" id="L238">        return null;</span>
    }

    /**
     * Offloaded version of get() to look up null keys. Null keys map to index
     * 0. This null case is split out into separate methods for the sake of
     * performance in the two most commonly used operations (get and put), but
     * incorporated with conditionals in others.
     */
    private V getForNullKey() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[0]; e != null; e = e.next) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (e.key == null)</span>
<span class="nc" id="L250">                return e.value;</span>
        }
<span class="nc" id="L252">        return null;</span>
    }

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     * key.
     *
     * @param key
     *            The key whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified
     *         key.
     */
    public boolean containsKey(Object key) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">        return getEntry(key) != null;</span>
    }

    /**
     * Returns the entry associated with the specified key in the SafelyHashMap.
     * Returns null if the SafelyHashMap contains no mapping for the key.
     */
    final Entry&lt;K, V&gt; getEntry(Object key) {
<span class="nc bnc" id="L273" title="All 4 branches missed.">        int hash = (key == null) ? 0</span>
<span class="nc" id="L274">                : (key instanceof String) ? hash(hashString((String) key))</span>
<span class="nc" id="L275">                : hash(key.hashCode());</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {</span>
            Object k;
<span class="nc bnc" id="L278" title="All 6 branches missed.">            if (e.hash == hash</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                    &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span>
<span class="nc" id="L280">                return e;</span>
        }
<span class="nc" id="L282">        return null;</span>
    }

    /**
     * Associates the specified value with the specified key in this map. If the
     * map previously contained a mapping for the key, the old value is
     * replaced.
     *
     * @param key
     *            key with which the specified value is to be associated
     * @param value
     *            value to be associated with the specified key
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;
     *         if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. (A &lt;tt&gt;null&lt;/tt&gt; return
     *         can also indicate that the map previously associated
     *         &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V put(K key, V value) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (key == null)</span>
<span class="nc" id="L301">            return putForNullKey(value);</span>
<span class="nc" id="L302">        int hash = 0;</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (key instanceof String)</span>
<span class="nc" id="L304">            hash = hash(hashString((String) key));</span>
        else
<span class="nc" id="L306">            hash = hash(key.hashCode());</span>
<span class="nc" id="L307">        int i = indexFor(hash, table.length);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {</span>
            Object k;
<span class="nc bnc" id="L310" title="All 6 branches missed.">            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</span>
<span class="nc" id="L311">                V oldValue = e.value;</span>
<span class="nc" id="L312">                e.value = value;</span>
<span class="nc" id="L313">                e.recordAccess(this);</span>
<span class="nc" id="L314">                return oldValue;</span>
            }
        }

<span class="nc" id="L318">        modCount++;</span>
<span class="nc" id="L319">        addEntry(hash, key, value, i);</span>
<span class="nc" id="L320">        return null;</span>
    }

    /**
     * Offloaded version of put for null keys
     */
    private V putForNullKey(V value) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[0]; e != null; e = e.next) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">            if (e.key == null) {</span>
<span class="nc" id="L329">                V oldValue = e.value;</span>
<span class="nc" id="L330">                e.value = value;</span>
<span class="nc" id="L331">                e.recordAccess(this);</span>
<span class="nc" id="L332">                return oldValue;</span>
            }
        }
<span class="nc" id="L335">        modCount++;</span>
<span class="nc" id="L336">        addEntry(0, null, value, 0);</span>
<span class="nc" id="L337">        return null;</span>
    }

    /**
     * This method is used instead of put by constructors and pseudoconstructors
     * (clone, readObject). It does not resize the table, check for
     * comodification, etc. It calls createEntry rather than addEntry.
     */
    private void putForCreate(K key, V value) {
<span class="nc bnc" id="L346" title="All 4 branches missed.">        int hash = (key == null) ? 0</span>
<span class="nc" id="L347">                : (key instanceof String) ? hash(hashString((String) key))</span>
<span class="nc" id="L348">                : hash(key.hashCode());</span>
<span class="nc" id="L349">        int i = indexFor(hash, table.length);</span>

        /**
         * Look for preexisting entry for key. This will never happen for clone
         * or deserialize. It will only happen for construction if the input Map
         * is a sorted map whose ordering is inconsistent w/ equals.
         */
<span class="nc bnc" id="L356" title="All 2 branches missed.">        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {</span>
            Object k;
<span class="nc bnc" id="L358" title="All 6 branches missed.">            if (e.hash == hash</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="nc" id="L360">                e.value = value;</span>
<span class="nc" id="L361">                return;</span>
            }
        }

<span class="nc" id="L365">        createEntry(hash, key, value, i);</span>
<span class="nc" id="L366">    }</span>

    private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L369">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                .entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L371">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span>
<span class="nc" id="L372">            putForCreate(e.getKey(), e.getValue());</span>
<span class="nc" id="L373">        }</span>
<span class="nc" id="L374">    }</span>

    /**
     * Rehashes the contents of this map into a new array with a larger
     * capacity. This method is called automatically when the number of keys in
     * this map reaches its threshold.
     *
     * If current capacity is MAXIMUM_CAPACITY, this method does not resize the
     * map, but sets threshold to Integer.MAX_VALUE. This has the effect of
     * preventing future calls.
     *
     * @param newCapacity
     *            the new capacity, MUST be a power of two; must be greater than
     *            current capacity unless current capacity is MAXIMUM_CAPACITY
     *            (in which case value is irrelevant).
     */
    void resize(int newCapacity) {
<span class="nc" id="L391">        Entry&lt;K, V&gt;[] oldTable = table;</span>
<span class="nc" id="L392">        int oldCapacity = oldTable.length;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        if (oldCapacity == MAXIMUM_CAPACITY) {</span>
<span class="nc" id="L394">            threshold = Integer.MAX_VALUE;</span>
<span class="nc" id="L395">            return;</span>
        }

<span class="nc" id="L398">        Entry&lt;K, V&gt;[] newTable = new Entry[newCapacity];</span>
<span class="nc" id="L399">        transfer(newTable);</span>
<span class="nc" id="L400">        table = newTable;</span>
<span class="nc" id="L401">        threshold = (int) (newCapacity * loadFactor);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Transfers all entries from current table to newTable.
     */
    void transfer(Entry[] newTable) {
<span class="nc" id="L408">        Entry[] src = table;</span>
<span class="nc" id="L409">        int newCapacity = newTable.length;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (int j = 0; j &lt; src.length; j++) {</span>
<span class="nc" id="L411">            Entry&lt;K, V&gt; e = src[j];</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (e != null) {</span>
<span class="nc" id="L413">                src[j] = null;</span>
                do {
<span class="nc" id="L415">                    Entry&lt;K, V&gt; next = e.next;</span>
<span class="nc" id="L416">                    int i = indexFor(e.hash, newCapacity);</span>
<span class="nc" id="L417">                    e.next = newTable[i];</span>
<span class="nc" id="L418">                    newTable[i] = e;</span>
<span class="nc" id="L419">                    e = next;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                } while (e != null);</span>
            }
        }
<span class="nc" id="L423">    }</span>

    /**
     * Copies all of the mappings from the specified map to this map. These
     * mappings will replace any mappings that this map had for any of the keys
     * currently in the specified map.
     *
     * @param m
     *            mappings to be stored in this map
     * @throws NullPointerException
     *             if the specified map is null
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L436">        int numKeysToBeAdded = m.size();</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">        if (numKeysToBeAdded == 0)</span>
<span class="nc" id="L438">            return;</span>

		/*
		 * Expand the map if the map if the number of mappings to be added is
		 * greater than or equal to threshold. This is conservative; the obvious
		 * condition is (m.size() + size) &gt;= threshold, but this condition could
		 * result in a map with twice the appropriate capacity, if the keys to
		 * be added overlap with the keys already in this map. By using the
		 * conservative calculation, we subject ourself to at most one extra
		 * resize.
		 */
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (numKeysToBeAdded &gt; threshold) {</span>
<span class="nc" id="L450">            int targetCapacity = (int) (numKeysToBeAdded / loadFactor + 1);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (targetCapacity &gt; MAXIMUM_CAPACITY)</span>
<span class="nc" id="L452">                targetCapacity = MAXIMUM_CAPACITY;</span>
<span class="nc" id="L453">            int newCapacity = table.length;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            while (newCapacity &lt; targetCapacity)</span>
<span class="nc" id="L455">                newCapacity &lt;&lt;= 1;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (newCapacity &gt; table.length)</span>
<span class="nc" id="L457">                resize(newCapacity);</span>
        }

<span class="nc" id="L460">        for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                .entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L462">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span>
<span class="nc" id="L463">            put(e.getKey(), e.getValue());</span>
<span class="nc" id="L464">        }</span>
<span class="nc" id="L465">    }</span>

    /**
     * Removes the mapping for the specified key from this map if present.
     *
     * @param key
     *            key whose mapping is to be removed from the map
     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or &lt;tt&gt;null&lt;/tt&gt;
     *         if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. (A &lt;tt&gt;null&lt;/tt&gt; return
     *         can also indicate that the map previously associated
     *         &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)
     */
    public V remove(Object key) {
<span class="nc" id="L478">        Entry&lt;K, V&gt; e = removeEntryForKey(key);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">        return (e == null ? null : e.value);</span>
    }

    /**
     * Removes and returns the entry associated with the specified key in the
     * SafelyHashMap. Returns null if the SafelyHashMap contains no mapping for
     * this key.
     */
    final Entry&lt;K, V&gt; removeEntryForKey(Object key) {
<span class="nc bnc" id="L488" title="All 4 branches missed.">        int hash = (key == null) ? 0</span>
<span class="nc" id="L489">                : (key instanceof String) ? hash(hashString((String) key))</span>
<span class="nc" id="L490">                : hash(key.hashCode());</span>
<span class="nc" id="L491">        int i = indexFor(hash, table.length);</span>
<span class="nc" id="L492">        Entry&lt;K, V&gt; prev = table[i];</span>
<span class="nc" id="L493">        Entry&lt;K, V&gt; e = prev;</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">        while (e != null) {</span>
<span class="nc" id="L496">            Entry&lt;K, V&gt; next = e.next;</span>
            Object k;
<span class="nc bnc" id="L498" title="All 6 branches missed.">            if (e.hash == hash</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {</span>
<span class="nc" id="L500">                modCount++;</span>
<span class="nc" id="L501">                size--;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (prev == e)</span>
<span class="nc" id="L503">                    table[i] = next;</span>
                else
<span class="nc" id="L505">                    prev.next = next;</span>
<span class="nc" id="L506">                e.recordRemoval(this);</span>
<span class="nc" id="L507">                return e;</span>
            }
<span class="nc" id="L509">            prev = e;</span>
<span class="nc" id="L510">            e = next;</span>
<span class="nc" id="L511">        }</span>

<span class="nc" id="L513">        return e;</span>
    }

    /**
     * Special version of remove for EntrySet.
     */
    final Entry&lt;K, V&gt; removeMapping(Object o) {
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L521">            return null;</span>

<span class="nc" id="L523">        Map.Entry&lt;K, V&gt; entry = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L524">        Object key = entry.getKey();</span>
<span class="nc bnc" id="L525" title="All 4 branches missed.">        int hash = (key == null) ? 0</span>
<span class="nc" id="L526">                : (key instanceof String) ? hash(hashString((String) key))</span>
<span class="nc" id="L527">                : hash(key.hashCode());</span>
<span class="nc" id="L528">        int i = indexFor(hash, table.length);</span>
<span class="nc" id="L529">        Entry&lt;K, V&gt; prev = table[i];</span>
<span class="nc" id="L530">        Entry&lt;K, V&gt; e = prev;</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">        while (e != null) {</span>
<span class="nc" id="L533">            Entry&lt;K, V&gt; next = e.next;</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">            if (e.hash == hash &amp;&amp; e.equals(entry)) {</span>
<span class="nc" id="L535">                modCount++;</span>
<span class="nc" id="L536">                size--;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (prev == e)</span>
<span class="nc" id="L538">                    table[i] = next;</span>
                else
<span class="nc" id="L540">                    prev.next = next;</span>
<span class="nc" id="L541">                e.recordRemoval(this);</span>
<span class="nc" id="L542">                return e;</span>
            }
<span class="nc" id="L544">            prev = e;</span>
<span class="nc" id="L545">            e = next;</span>
<span class="nc" id="L546">        }</span>

<span class="nc" id="L548">        return e;</span>
    }

    /**
     * Removes all of the mappings from this map. The map will be empty after
     * this call returns.
     */
    public void clear() {
<span class="nc" id="L556">        modCount++;</span>
<span class="nc" id="L557">        Entry[] tab = table;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i++)</span>
<span class="nc" id="L559">            tab[i] = null;</span>
<span class="nc" id="L560">        size = 0;</span>
<span class="nc" id="L561">    }</span>

    /**
     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the specified
     * value.
     *
     * @param value
     *            value whose presence in this map is to be tested
     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the specified
     *         value
     */
    public boolean containsValue(Object value) {
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (value == null)</span>
<span class="nc" id="L574">            return containsNullValue();</span>

<span class="nc" id="L576">        Entry[] tab = table;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i++)</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            for (Entry e = tab[i]; e != null; e = e.next)</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (value.equals(e.value))</span>
<span class="nc" id="L580">                    return true;</span>
<span class="nc" id="L581">        return false;</span>
    }

    /**
     * Special-case code for containsValue with null argument
     */
    private boolean containsNullValue() {
<span class="nc" id="L588">        Entry[] tab = table;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">        for (int i = 0; i &lt; tab.length; i++)</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">            for (Entry e = tab[i]; e != null; e = e.next)</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                if (e.value == null)</span>
<span class="nc" id="L592">                    return true;</span>
<span class="nc" id="L593">        return false;</span>
    }

    /**
     * Returns a shallow copy of this &lt;tt&gt;SafelyHashMap&lt;/tt&gt; instance: the keys
     * and values themselves are not cloned.
     *
     * @return a shallow copy of this map
     */
    public Object clone() {
<span class="nc" id="L603">        AntiCollisionHashMap&lt;K, V&gt; result = null;</span>
        try {
<span class="nc" id="L605">            result = (AntiCollisionHashMap&lt;K, V&gt;) super.clone();</span>
<span class="nc" id="L606">        } catch (CloneNotSupportedException e) {</span>
            // assert false;
<span class="nc" id="L608">        }</span>
<span class="nc" id="L609">        result.table = new Entry[table.length];</span>
<span class="nc" id="L610">        result.entrySet = null;</span>
<span class="nc" id="L611">        result.modCount = 0;</span>
<span class="nc" id="L612">        result.size = 0;</span>
<span class="nc" id="L613">        result.init();</span>
<span class="nc" id="L614">        result.putAllForCreate(this);</span>

<span class="nc" id="L616">        return result;</span>
    }

    static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; {
        final K key;
        V value;
        Entry&lt;K, V&gt; next;
        final int hash;

        /**
         * Creates new entry.
         */
<span class="nc" id="L628">        Entry(int h, K k, V v, Entry&lt;K, V&gt; n) {</span>
<span class="nc" id="L629">            value = v;</span>
<span class="nc" id="L630">            next = n;</span>
<span class="nc" id="L631">            key = k;</span>
<span class="nc" id="L632">            hash = h;</span>
<span class="nc" id="L633">        }</span>

        public final K getKey() {
<span class="nc" id="L636">            return key;</span>
        }

        public final V getValue() {
<span class="nc" id="L640">            return value;</span>
        }

        public final V setValue(V newValue) {
<span class="nc" id="L644">            V oldValue = value;</span>
<span class="nc" id="L645">            value = newValue;</span>
<span class="nc" id="L646">            return oldValue;</span>
        }

        public final boolean equals(Object o) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L651">                return false;</span>
<span class="nc" id="L652">            Map.Entry e = (Map.Entry) o;</span>
<span class="nc" id="L653">            Object k1 = getKey();</span>
<span class="nc" id="L654">            Object k2 = e.getKey();</span>
<span class="nc bnc" id="L655" title="All 6 branches missed.">            if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) {</span>
<span class="nc" id="L656">                Object v1 = getValue();</span>
<span class="nc" id="L657">                Object v2 = e.getValue();</span>
<span class="nc bnc" id="L658" title="All 6 branches missed.">                if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2)))</span>
<span class="nc" id="L659">                    return true;</span>
            }
<span class="nc" id="L661">            return false;</span>
        }

        public final int hashCode() {
<span class="nc bnc" id="L665" title="All 4 branches missed.">            return (key == null ? 0 : key.hashCode())</span>
<span class="nc" id="L666">                    ^ (value == null ? 0 : value.hashCode());</span>
        }

        public final String toString() {
<span class="nc" id="L670">            return getKey() + &quot;=&quot; + getValue();</span>
        }

        /**
         * This method is invoked whenever the value in an entry is overwritten
         * by an invocation of put(k,v) for a key k that's already in the
         * SafelyHashMap.
         */
        void recordAccess(AntiCollisionHashMap&lt;K, V&gt; m) {
<span class="nc" id="L679">        }</span>

        /**
         * This method is invoked whenever the entry is removed from the table.
         */
        void recordRemoval(AntiCollisionHashMap&lt;K, V&gt; m) {
<span class="nc" id="L685">        }</span>
    }

    /**
     * Adds a new entry with the specified key, value and hash code to the
     * specified bucket. It is the responsibility of this method to resize the
     * table if appropriate.
     *
     * Subclass overrides this to alter the behavior of put method.
     */
    void addEntry(int hash, K key, V value, int bucketIndex) {
<span class="nc" id="L696">        Entry&lt;K, V&gt; e = table[bucketIndex];</span>
<span class="nc" id="L697">        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (size++ &gt;= threshold)</span>
<span class="nc" id="L699">            resize(2 * table.length);</span>
<span class="nc" id="L700">    }</span>

    /**
     * Like addEntry except that this version is used when creating entries as
     * part of Map construction or &quot;pseudo-construction&quot; (cloning,
     * deserialization). This version needn't worry about resizing the table.
     *
     * Subclass overrides this to alter the behavior of SafelyHashMap(Map),
     * clone, and readObject.
     */
    void createEntry(int hash, K key, V value, int bucketIndex) {
<span class="nc" id="L711">        Entry&lt;K, V&gt; e = table[bucketIndex];</span>
<span class="nc" id="L712">        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);</span>
<span class="nc" id="L713">        size++;</span>
<span class="nc" id="L714">    }</span>

    private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; {
        Entry&lt;K, V&gt; next; // next entry to return
        int expectedModCount; // For fast-fail
        int index; // current slot
        Entry&lt;K, V&gt; current; // current entry

<span class="nc" id="L722">        HashIterator() {</span>
<span class="nc" id="L723">            expectedModCount = modCount;</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (size &gt; 0) { // advance to first entry</span>
<span class="nc" id="L725">                Entry[] t = table;</span>
<span class="nc bnc" id="L726" title="All 4 branches missed.">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span>
<span class="nc" id="L727">                    ;</span>
            }
<span class="nc" id="L729">        }</span>

        public final boolean hasNext() {
<span class="nc bnc" id="L732" title="All 2 branches missed.">            return next != null;</span>
        }

        final Entry&lt;K, V&gt; nextEntry() {
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L737">                throw new ConcurrentModificationException();</span>
<span class="nc" id="L738">            Entry&lt;K, V&gt; e = next;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (e == null)</span>
<span class="nc" id="L740">                throw new NoSuchElementException();</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">            if ((next = e.next) == null) {</span>
<span class="nc" id="L743">                Entry[] t = table;</span>
<span class="nc bnc" id="L744" title="All 4 branches missed.">                while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</span>
<span class="nc" id="L745">                    ;</span>
            }
<span class="nc" id="L747">            current = e;</span>
<span class="nc" id="L748">            return e;</span>
        }

        public void remove() {
<span class="nc bnc" id="L752" title="All 2 branches missed.">            if (current == null)</span>
<span class="nc" id="L753">                throw new IllegalStateException();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            if (modCount != expectedModCount)</span>
<span class="nc" id="L755">                throw new ConcurrentModificationException();</span>
<span class="nc" id="L756">            Object k = current.key;</span>
<span class="nc" id="L757">            current = null;</span>
<span class="nc" id="L758">            AntiCollisionHashMap.this.removeEntryForKey(k);</span>
<span class="nc" id="L759">            expectedModCount = modCount;</span>
<span class="nc" id="L760">        }</span>

    }

<span class="nc" id="L764">    private final class ValueIterator extends HashIterator&lt;V&gt; {</span>
        public V next() {
<span class="nc" id="L766">            return nextEntry().value;</span>
        }
    }

<span class="nc" id="L770">    private final class KeyIterator extends HashIterator&lt;K&gt; {</span>
        public K next() {
<span class="nc" id="L772">            return nextEntry().getKey();</span>
        }
    }

<span class="nc" id="L776">    private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
        public Map.Entry&lt;K, V&gt; next() {
<span class="nc" id="L778">            return nextEntry();</span>
        }
    }

    // Subclass overrides these to alter behavior of views' iterator() method
    Iterator&lt;K&gt; newKeyIterator() {
<span class="nc" id="L784">        return new KeyIterator();</span>
    }

    Iterator&lt;V&gt; newValueIterator() {
<span class="nc" id="L788">        return new ValueIterator();</span>
    }

    Iterator&lt;Map.Entry&lt;K, V&gt;&gt; newEntryIterator() {
<span class="nc" id="L792">        return new EntryIterator();</span>
    }

    // Views

<span class="nc" id="L797">    private transient Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = null;</span>

    /**
     * Returns a {@link Set} view of the keys contained in this map. The set is
     * backed by the map, so changes to the map are reflected in the set, and
     * vice-versa. If the map is modified while an iteration over the set is in
     * progress (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation),
     * the results of the iteration are undefined. The set supports element
     * removal, which removes the corresponding mapping from the map, via the
     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,
     * &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support
     * the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     */
    public Set&lt;K&gt; keySet() {

<span class="nc" id="L812">        Set&lt;K&gt; ks = keySet;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">        return (ks != null ? ks : (keySet = new KeySet()));</span>
    }

<span class="nc" id="L816">    private final class KeySet extends AbstractSet&lt;K&gt; {</span>
        public Iterator&lt;K&gt; iterator() {
<span class="nc" id="L818">            return newKeyIterator();</span>
        }

        public int size() {
<span class="nc" id="L822">            return size;</span>
        }

        public boolean contains(Object o) {
<span class="nc" id="L826">            return containsKey(o);</span>
        }

        public boolean remove(Object o) {
<span class="nc bnc" id="L830" title="All 2 branches missed.">            return AntiCollisionHashMap.this.removeEntryForKey(o) != null;</span>
        }

        public void clear() {
<span class="nc" id="L834">            AntiCollisionHashMap.this.clear();</span>
<span class="nc" id="L835">        }</span>
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are reflected
     * in the collection, and vice-versa. If the map is modified while an
     * iteration over the collection is in progress (except through the
     * iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of the iteration
     * are undefined. The collection supports element removal, which removes the
     * corresponding mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,
     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and
     * &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support the &lt;tt&gt;add&lt;/tt&gt; or
     * &lt;tt&gt;addAll&lt;/tt&gt; operations.
     */
    public Collection&lt;V&gt; values() {
<span class="nc" id="L851">        Collection&lt;V&gt; vs = values;</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">        return (vs != null ? vs : (values = new Values()));</span>
    }

<span class="nc" id="L855">    private final class Values extends AbstractCollection&lt;V&gt; {</span>
        public Iterator&lt;V&gt; iterator() {
<span class="nc" id="L857">            return newValueIterator();</span>
        }

        public int size() {
<span class="nc" id="L861">            return size;</span>
        }

        public boolean contains(Object o) {
<span class="nc" id="L865">            return containsValue(o);</span>
        }

        public void clear() {
<span class="nc" id="L869">            AntiCollisionHashMap.this.clear();</span>
<span class="nc" id="L870">        }</span>
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map. The set
     * is backed by the map, so changes to the map are reflected in the set, and
     * vice-versa. If the map is modified while an iteration over the set is in
     * progress (except through the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation, or
     * through the &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the
     * iterator) the results of the iteration are undefined. The set supports
     * element removal, which removes the corresponding mapping from the map,
     * via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;
     * , &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations. It does not support
     * the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.
     *
     * @return a set view of the mappings contained in this map
     */
    public Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet() {
<span class="nc" id="L888">        return entrySet0();</span>
    }

    private Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet0() {
<span class="nc" id="L892">        Set&lt;Map.Entry&lt;K, V&gt;&gt; es = entrySet;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">        return es != null ? es : (entrySet = new EntrySet());</span>
    }

<span class="nc" id="L896">    private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K, V&gt;&gt; {</span>
        public Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() {
<span class="nc" id="L898">            return newEntryIterator();</span>
        }

        public boolean contains(Object o) {
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if (!(o instanceof Map.Entry))</span>
<span class="nc" id="L903">                return false;</span>
<span class="nc" id="L904">            Map.Entry&lt;K, V&gt; e = (Map.Entry&lt;K, V&gt;) o;</span>
<span class="nc" id="L905">            Entry&lt;K, V&gt; candidate = getEntry(e.getKey());</span>
<span class="nc bnc" id="L906" title="All 4 branches missed.">            return candidate != null &amp;&amp; candidate.equals(e);</span>
        }

        public boolean remove(Object o) {
<span class="nc bnc" id="L910" title="All 2 branches missed.">            return removeMapping(o) != null;</span>
        }

        public int size() {
<span class="nc" id="L914">            return size;</span>
        }

        public void clear() {
<span class="nc" id="L918">            AntiCollisionHashMap.this.clear();</span>
<span class="nc" id="L919">        }</span>
    }

    /**
     * Save the state of the &lt;tt&gt;SafelyHashMap&lt;/tt&gt; instance to a stream (i.e.,
     * serialize it).
     *
     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the SafelyHashMap (the length of the
     *             bucket array) is emitted (int), followed by the &lt;i&gt;size&lt;/i&gt;
     *             (an int, the number of key-value mappings), followed by the
     *             key (Object) and value (Object) for each key-value mapping.
     *             The key-value mappings are emitted in no particular order.
     */
    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
<span class="nc bnc" id="L933" title="All 2 branches missed.">        Iterator&lt;Map.Entry&lt;K, V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator()</span>
                : null;

        // Write out the threshold, loadfactor, and any hidden stuff
<span class="nc" id="L937">        s.defaultWriteObject();</span>

        // Write out number of buckets
<span class="nc" id="L940">        s.writeInt(table.length);</span>

        // Write out size (number of Mappings)
<span class="nc" id="L943">        s.writeInt(size);</span>

        // Write out keys and values (alternating)
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (i != null) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L948">                Map.Entry&lt;K, V&gt; e = i.next();</span>
<span class="nc" id="L949">                s.writeObject(e.getKey());</span>
<span class="nc" id="L950">                s.writeObject(e.getValue());</span>
<span class="nc" id="L951">            }</span>
        }
<span class="nc" id="L953">    }</span>

    private static final long serialVersionUID = 362498820763181265L;

    /**
     * Reconstitute the &lt;tt&gt;SafelyHashMap&lt;/tt&gt; instance from a stream (i.e.,
     * deserialize it).
     */
    private void readObject(java.io.ObjectInputStream s) throws IOException,
            ClassNotFoundException {
        // Read in the threshold, loadfactor, and any hidden stuff
<span class="nc" id="L964">        s.defaultReadObject();</span>

        // Read in number of buckets and allocate the bucket array;
<span class="nc" id="L967">        int numBuckets = s.readInt();</span>
<span class="nc" id="L968">        table = new Entry[numBuckets];</span>

<span class="nc" id="L970">        init(); // Give subclass a chance to do its thing.</span>

        // Read in size (number of Mappings)
<span class="nc" id="L973">        int size = s.readInt();</span>

        // Read the keys and values, and put the mappings in the SafelyHashMap
<span class="nc bnc" id="L976" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L977">            K key = (K) s.readObject();</span>
<span class="nc" id="L978">            V value = (V) s.readObject();</span>
<span class="nc" id="L979">            putForCreate(key, value);</span>
        }
<span class="nc" id="L981">    }</span>

    // These methods are used when serializing HashSets
    int capacity() {
<span class="nc" id="L985">        return table.length;</span>
    }

    float loadFactor() {
<span class="nc" id="L989">        return loadFactor;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>