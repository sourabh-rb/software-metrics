<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IOUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">fastjson</a> &gt; <a href="index.source.html" class="el_package">com.alibaba.fastjson.util</a> &gt; <span class="el_source">IOUtils.java</span></div><h1>IOUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 1999-2017 Alibaba Group.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.alibaba.fastjson.util;

import java.io.Closeable;
import java.io.InputStream;
import java.io.Reader;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.MalformedInputException;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Properties;

import com.alibaba.fastjson.JSONException;

/**
 * @author wenshao[szujobs@hotmail.com]
 */
<span class="fc" id="L38">public class IOUtils {</span>
    
    public  final  static String FASTJSON_PROPERTIES  =&quot;fastjson.properties&quot;;
    
    public final static String FASTJSON_COMPATIBLEWITHJAVABEAN=&quot;fastjson.compatibleWithJavaBean&quot;;
    
    public final static String FASTJSON_COMPATIBLEWITHFIELDNAME=&quot;fastjson.compatibleWithFieldName&quot;;
    
<span class="fc" id="L46">    public final static Properties DEFAULT_PROPERTIES =new Properties();    </span>

<span class="fc" id="L48">    public final static Charset   UTF8                 = Charset.forName(&quot;UTF-8&quot;);</span>
    
<span class="fc" id="L50">    public final static char[]    DIGITS                     = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A',</span>
            'B', 'C', 'D', 'E', 'F'                         };

<span class="fc" id="L53">    public final static boolean[] firstIdentifierFlags       = new boolean[256];</span>
    static {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        for (char c = 0; c &lt; firstIdentifierFlags.length; ++c) {</span>
<span class="fc bfc" id="L56" title="All 4 branches covered.">            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {</span>
<span class="fc" id="L57">                firstIdentifierFlags[c] = true;</span>
<span class="fc bfc" id="L58" title="All 4 branches covered.">            } else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
<span class="fc" id="L59">                firstIdentifierFlags[c] = true;</span>
<span class="fc bfc" id="L60" title="All 4 branches covered.">            } else if (c == '_' || c == '$') {</span>
<span class="fc" id="L61">                firstIdentifierFlags[c] = true;</span>
            }
        }
    }

<span class="fc" id="L66">    public final static boolean[] identifierFlags            = new boolean[256];</span>

    static {
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (char c = 0; c &lt; identifierFlags.length; ++c) {</span>
<span class="fc bfc" id="L70" title="All 4 branches covered.">            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {</span>
<span class="fc" id="L71">                identifierFlags[c] = true;</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">            } else if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
<span class="fc" id="L73">                identifierFlags[c] = true;</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">            } else if (c == '_') {</span>
<span class="fc" id="L75">                identifierFlags[c] = true;</span>
<span class="fc bfc" id="L76" title="All 4 branches covered.">            } else if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L77">                identifierFlags[c] = true;</span>
            }
        }
    }
    
    static {
        try {
<span class="fc" id="L84">            loadPropertiesFromFile();</span>
<span class="nc" id="L85">        } catch (Throwable e) {</span>
            //skip
<span class="fc" id="L87">        }</span>
    }
    
    public static String getStringProperty(String name) {
<span class="fc" id="L91">        String prop = null;</span>
        try {
<span class="fc" id="L93">            prop = System.getProperty(name);</span>
<span class="nc" id="L94">        } catch (SecurityException e) {</span>
            //skip
<span class="fc" id="L96">        }</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        return (prop == null) ? DEFAULT_PROPERTIES.getProperty(name) : prop;</span>
    }
    
    public static void loadPropertiesFromFile(){
<span class="fc" id="L101">        InputStream imputStream = AccessController.doPrivileged(new PrivilegedAction&lt;InputStream&gt;() {</span>
            public InputStream run() {
<span class="fc" id="L103">                ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">                if (cl != null) {</span>
<span class="fc" id="L105">                    return cl.getResourceAsStream(FASTJSON_PROPERTIES);</span>
                } else {
<span class="nc" id="L107">                    return ClassLoader.getSystemResourceAsStream(FASTJSON_PROPERTIES);</span>
                }
            }
        });
        
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (null != imputStream) {</span>
            try {
<span class="fc" id="L114">                DEFAULT_PROPERTIES.load(imputStream);</span>
<span class="fc" id="L115">                imputStream.close();</span>
<span class="nc" id="L116">            } catch (java.io.IOException e) {</span>
                // skip
<span class="fc" id="L118">            }</span>
        }
<span class="fc" id="L120">    }</span>

<span class="fc" id="L122">    public final static byte[]    specicalFlags_doubleQuotes = new byte[161];</span>
<span class="fc" id="L123">    public final static byte[]    specicalFlags_singleQuotes = new byte[161];</span>
<span class="fc" id="L124">    public final static boolean[] specicalFlags_doubleQuotesFlags = new boolean[161];</span>
<span class="fc" id="L125">    public final static boolean[] specicalFlags_singleQuotesFlags = new boolean[161];</span>

<span class="fc" id="L127">    public final static char[]    replaceChars               = new char[93];</span>
    static {
<span class="fc" id="L129">        specicalFlags_doubleQuotes['\0'] = 4;</span>
<span class="fc" id="L130">        specicalFlags_doubleQuotes['\1'] = 4;</span>
<span class="fc" id="L131">        specicalFlags_doubleQuotes['\2'] = 4;</span>
<span class="fc" id="L132">        specicalFlags_doubleQuotes['\3'] = 4;</span>
<span class="fc" id="L133">        specicalFlags_doubleQuotes['\4'] = 4;</span>
<span class="fc" id="L134">        specicalFlags_doubleQuotes['\5'] = 4;</span>
<span class="fc" id="L135">        specicalFlags_doubleQuotes['\6'] = 4;</span>
<span class="fc" id="L136">        specicalFlags_doubleQuotes['\7'] = 4;</span>
<span class="fc" id="L137">        specicalFlags_doubleQuotes['\b'] = 1; // 8</span>
<span class="fc" id="L138">        specicalFlags_doubleQuotes['\t'] = 1; // 9</span>
<span class="fc" id="L139">        specicalFlags_doubleQuotes['\n'] = 1; // 10</span>
<span class="fc" id="L140">        specicalFlags_doubleQuotes['\u000B'] = 4; // 11</span>
<span class="fc" id="L141">        specicalFlags_doubleQuotes['\f'] = 1; // 12</span>
<span class="fc" id="L142">        specicalFlags_doubleQuotes['\r'] = 1; // 13</span>
<span class="fc" id="L143">        specicalFlags_doubleQuotes['\&quot;'] = 1; // 34</span>
<span class="fc" id="L144">        specicalFlags_doubleQuotes['\\'] = 1; // 92</span>

<span class="fc" id="L146">        specicalFlags_singleQuotes['\0'] = 4;</span>
<span class="fc" id="L147">        specicalFlags_singleQuotes['\1'] = 4;</span>
<span class="fc" id="L148">        specicalFlags_singleQuotes['\2'] = 4;</span>
<span class="fc" id="L149">        specicalFlags_singleQuotes['\3'] = 4;</span>
<span class="fc" id="L150">        specicalFlags_singleQuotes['\4'] = 4;</span>
<span class="fc" id="L151">        specicalFlags_singleQuotes['\5'] = 4;</span>
<span class="fc" id="L152">        specicalFlags_singleQuotes['\6'] = 4;</span>
<span class="fc" id="L153">        specicalFlags_singleQuotes['\7'] = 4;</span>
<span class="fc" id="L154">        specicalFlags_singleQuotes['\b'] = 1; // 8</span>
<span class="fc" id="L155">        specicalFlags_singleQuotes['\t'] = 1; // 9</span>
<span class="fc" id="L156">        specicalFlags_singleQuotes['\n'] = 1; // 10</span>
<span class="fc" id="L157">        specicalFlags_singleQuotes['\u000B'] = 4; // 11</span>
<span class="fc" id="L158">        specicalFlags_singleQuotes['\f'] = 1; // 12</span>
<span class="fc" id="L159">        specicalFlags_singleQuotes['\r'] = 1; // 13</span>
<span class="fc" id="L160">        specicalFlags_singleQuotes['\\'] = 1; // 92</span>
<span class="fc" id="L161">        specicalFlags_singleQuotes['\''] = 1; // 39</span>

<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (int i = 14; i &lt;= 31; ++i) {</span>
<span class="fc" id="L164">            specicalFlags_doubleQuotes[i] = 4;</span>
<span class="fc" id="L165">            specicalFlags_singleQuotes[i] = 4;</span>
        }

<span class="fc bfc" id="L168" title="All 2 branches covered.">        for (int i = 127; i &lt; 160; ++i) {</span>
<span class="fc" id="L169">            specicalFlags_doubleQuotes[i] = 4;</span>
<span class="fc" id="L170">            specicalFlags_singleQuotes[i] = 4;</span>
        }
        
<span class="fc bfc" id="L173" title="All 2 branches covered.">        for (int i = 0; i &lt; 161; ++i) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            specicalFlags_doubleQuotesFlags[i] = specicalFlags_doubleQuotes[i] != 0;</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            specicalFlags_singleQuotesFlags[i] = specicalFlags_singleQuotes[i] != 0;</span>
        }

<span class="fc" id="L178">        replaceChars['\0'] = '0';</span>
<span class="fc" id="L179">        replaceChars['\1'] = '1';</span>
<span class="fc" id="L180">        replaceChars['\2'] = '2';</span>
<span class="fc" id="L181">        replaceChars['\3'] = '3';</span>
<span class="fc" id="L182">        replaceChars['\4'] = '4';</span>
<span class="fc" id="L183">        replaceChars['\5'] = '5';</span>
<span class="fc" id="L184">        replaceChars['\6'] = '6';</span>
<span class="fc" id="L185">        replaceChars['\7'] = '7';</span>
<span class="fc" id="L186">        replaceChars['\b'] = 'b'; // 8</span>
<span class="fc" id="L187">        replaceChars['\t'] = 't'; // 9</span>
<span class="fc" id="L188">        replaceChars['\n'] = 'n'; // 10</span>
<span class="fc" id="L189">        replaceChars['\u000B'] = 'v'; // 11</span>
<span class="fc" id="L190">        replaceChars['\f'] = 'f'; // 12</span>
<span class="fc" id="L191">        replaceChars['\r'] = 'r'; // 13</span>
<span class="fc" id="L192">        replaceChars['\&quot;'] = '&quot;'; // 34</span>
<span class="fc" id="L193">        replaceChars['\''] = '\''; // 39</span>
<span class="fc" id="L194">        replaceChars['/'] = '/'; // 47</span>
<span class="fc" id="L195">        replaceChars['\\'] = '\\'; // 92</span>
    }

<span class="fc" id="L198">    public final static char[]    ASCII_CHARS                = { '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0',</span>
            '5', '0', '6', '0', '7', '0', '8', '0', '9', '0', 'A', '0', 'B', '0', 'C', '0', 'D', '0', 'E', '0', 'F',
            '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '1', '8', '1', '9', '1',
            'A', '1', 'B', '1', 'C', '1', 'D', '1', 'E', '1', 'F', '2', '0', '2', '1', '2', '2', '2', '3', '2', '4',
            '2', '5', '2', '6', '2', '7', '2', '8', '2', '9', '2', 'A', '2', 'B', '2', 'C', '2', 'D', '2', 'E', '2',
            'F',                                            };

    public static void close(Closeable x) {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (x != null) {</span>
            try {
<span class="fc" id="L208">                x.close();</span>
<span class="nc" id="L209">            } catch (Exception e) {</span>
                // skip
<span class="fc" id="L211">            }</span>
        }
<span class="fc" id="L213">    }</span>

    // Requires positive x
    public static int stringSize(long x) {
<span class="fc" id="L217">        long p = 10;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">        for (int i = 1; i &lt; 19; i++) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (x &lt; p) return i;</span>
<span class="fc" id="L220">            p = 10 * p;</span>
        }
<span class="fc" id="L222">        return 19;</span>
    }

    public static void getChars(long i, int index, char[] buf) {
        long q;
        int r;
<span class="fc" id="L228">        int charPos = index;</span>
<span class="fc" id="L229">        char sign = 0;</span>

<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L232">            sign = '-';</span>
<span class="fc" id="L233">            i = -i;</span>
        }

        // Get 2 digits/iteration using longs until quotient fits into an int
<span class="fc bfc" id="L237" title="All 2 branches covered.">        while (i &gt; Integer.MAX_VALUE) {</span>
<span class="fc" id="L238">            q = i / 100;</span>
            // really: r = i - (q * 100);
<span class="fc" id="L240">            r = (int) (i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)));</span>
<span class="fc" id="L241">            i = q;</span>
<span class="fc" id="L242">            buf[--charPos] = DigitOnes[r];</span>
<span class="fc" id="L243">            buf[--charPos] = DigitTens[r];</span>
        }

        // Get 2 digits/iteration using ints
        int q2;
<span class="fc" id="L248">        int i2 = (int) i;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        while (i2 &gt;= 65536) {</span>
<span class="fc" id="L250">            q2 = i2 / 100;</span>
            // really: r = i2 - (q * 100);
<span class="fc" id="L252">            r = i2 - ((q2 &lt;&lt; 6) + (q2 &lt;&lt; 5) + (q2 &lt;&lt; 2));</span>
<span class="fc" id="L253">            i2 = q2;</span>
<span class="fc" id="L254">            buf[--charPos] = DigitOnes[r];</span>
<span class="fc" id="L255">            buf[--charPos] = DigitTens[r];</span>
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i2 &lt;= 65536, i2);
        for (;;) {
<span class="fc" id="L261">            q2 = (i2 * 52429) &gt;&gt;&gt; (16 + 3);</span>
<span class="fc" id="L262">            r = i2 - ((q2 &lt;&lt; 3) + (q2 &lt;&lt; 1)); // r = i2-(q2*10) ...</span>
<span class="fc" id="L263">            buf[--charPos] = digits[r];</span>
<span class="fc" id="L264">            i2 = q2;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (i2 == 0) break;</span>
        }
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (sign != 0) {</span>
<span class="fc" id="L268">            buf[--charPos] = sign;</span>
        }
<span class="fc" id="L270">    }</span>

    /**
     * Places characters representing the integer i into the character array buf. The characters are placed into the
     * buffer backwards starting with the least significant digit at the specified index (exclusive), and working
     * backwards from there. Will fail if i == Integer.MIN_VALUE
     */
    public static void getChars(int i, int index, char[] buf) {
<span class="fc" id="L278">        int q, r, p = index;</span>
<span class="fc" id="L279">        char sign = 0;</span>

<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L282">            sign = '-';</span>
<span class="fc" id="L283">            i = -i;</span>
        }

<span class="fc bfc" id="L286" title="All 2 branches covered.">        while (i &gt;= 65536) {</span>
<span class="fc" id="L287">            q = i / 100;</span>
            // really: r = i - (q * 100);
<span class="fc" id="L289">            r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2));</span>
<span class="fc" id="L290">            i = q;</span>
<span class="fc" id="L291">            buf[--p] = DigitOnes[r];</span>
<span class="fc" id="L292">            buf[--p] = DigitTens[r];</span>
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i &lt;= 65536, i);
        for (;;) {
<span class="fc" id="L298">            q = (i * 52429) &gt;&gt;&gt; (16 + 3);</span>
<span class="fc" id="L299">            r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ...</span>
<span class="fc" id="L300">            buf[--p] = digits[r];</span>
<span class="fc" id="L301">            i = q;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">            if (i == 0) break;</span>
        }
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (sign != 0) {</span>
<span class="fc" id="L305">            buf[--p] = sign;</span>
        }
<span class="fc" id="L307">    }</span>

    public static void getChars(byte b, int index, char[] buf) {
<span class="fc" id="L310">        int i = b;</span>
        int q, r;
<span class="fc" id="L312">        int charPos = index;</span>
<span class="fc" id="L313">        char sign = 0;</span>

<span class="pc bpc" id="L315" title="1 of 2 branches missed.">        if (i &lt; 0) {</span>
<span class="fc" id="L316">            sign = '-';</span>
<span class="fc" id="L317">            i = -i;</span>
        }

        // Fall thru to fast mode for smaller numbers
        // assert(i &lt;= 65536, i);
        for (;;) {
<span class="fc" id="L323">            q = (i * 52429) &gt;&gt;&gt; (16 + 3);</span>
<span class="fc" id="L324">            r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ...</span>
<span class="fc" id="L325">            buf[--charPos] = digits[r];</span>
<span class="fc" id="L326">            i = q;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (i == 0) break;</span>
        }
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        if (sign != 0) {</span>
<span class="fc" id="L330">            buf[--charPos] = sign;</span>
        }
<span class="fc" id="L332">    }</span>

    /**
     * All possible chars for representing a number as a String
     */
<span class="fc" id="L337">    final static char[] digits    = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',</span>
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };

<span class="fc" id="L340">    final static char[] DigitTens = { '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1',</span>
            '1', '1', '1', '1', '2', '2', '2', '2', '2', '2', '2', '2', '2', '2', '3', '3', '3', '3', '3', '3', '3',
            '3', '3', '3', '4', '4', '4', '4', '4', '4', '4', '4', '4', '4', '5', '5', '5', '5', '5', '5', '5', '5',
            '5', '5', '6', '6', '6', '6', '6', '6', '6', '6', '6', '6', '7', '7', '7', '7', '7', '7', '7', '7', '7',
            '7', '8', '8', '8', '8', '8', '8', '8', '8', '8', '8', '9', '9', '9', '9', '9', '9', '9', '9', '9', '9', };

<span class="fc" id="L346">    final static char[] DigitOnes = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5',</span>
            '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6',
            '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8',
            '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', };

<span class="fc" id="L352">    final static int[]  sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE };</span>

    // Requires positive x
    public static int stringSize(int x) {
<span class="fc" id="L356">        for (int i = 0;; i++) {</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">            if (x &lt;= sizeTable[i]) {</span>
<span class="fc" id="L358">                return i + 1;</span>
            }
        }
    }

    public static void decode(CharsetDecoder charsetDecoder, ByteBuffer byteBuf, CharBuffer charByte) {
        try {
<span class="fc" id="L365">            CoderResult cr = charsetDecoder.decode(byteBuf, charByte, true);</span>

<span class="pc bpc" id="L367" title="1 of 2 branches missed.">            if (!cr.isUnderflow()) {</span>
<span class="nc" id="L368">                cr.throwException();</span>
            }

<span class="fc" id="L371">            cr = charsetDecoder.flush(charByte);</span>

<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            if (!cr.isUnderflow()) {</span>
<span class="nc" id="L374">                cr.throwException();</span>
            }
<span class="nc" id="L376">        } catch (CharacterCodingException x) {</span>
            // Substitution is always enabled,
            // so this shouldn't happen
<span class="nc" id="L379">            throw new JSONException(&quot;utf8 decode error, &quot; + x.getMessage(), x);</span>
<span class="fc" id="L380">        }</span>
<span class="fc" id="L381">    }</span>

    public static boolean firstIdentifier(char ch) {
<span class="pc bpc" id="L384" title="1 of 4 branches missed.">        return ch &lt; IOUtils.firstIdentifierFlags.length &amp;&amp; IOUtils.firstIdentifierFlags[ch];</span>
    }
    
    public static boolean isIdent(char ch) {
<span class="pc bpc" id="L388" title="1 of 4 branches missed.">        return ch &lt; identifierFlags.length &amp;&amp; identifierFlags[ch];</span>
    }
    
<span class="fc" id="L391">    public static final char[] CA = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.toCharArray();</span>
<span class="fc" id="L392">    public static final int[]  IA = new int[256];</span>
    static {
<span class="fc" id="L394">        Arrays.fill(IA, -1);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (int i = 0, iS = CA.length; i &lt; iS; i++)</span>
<span class="fc" id="L396">            IA[CA[i]] = i;</span>
<span class="fc" id="L397">        IA['='] = 0;</span>
<span class="fc" id="L398">    }</span>

    /**
     * Decodes a BASE64 encoded char array that is known to be resonably well formatted. The method is about twice as
     * fast as #decode(char[]). The preconditions are:&lt;br&gt;
     * + The array must have a line length of 76 chars OR no line separators at all (one line).&lt;br&gt;
     * + Line separator must be &quot;\r\n&quot;, as specified in RFC 2045 + The array must not contain illegal characters within
     * the encoded string&lt;br&gt;
     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.&lt;br&gt;
     * 
     * @param chars The source array. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
     * @return The decoded array of bytes. May be of length 0.
     */
    public static byte[] decodeBase64(char[] chars, int offset, int charsLen) {
        // Check special case
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (charsLen == 0) {</span>
<span class="fc" id="L414">            return new byte[0];</span>
        }

<span class="fc" id="L417">        int sIx = offset, eIx = offset + charsLen - 1; // Start and end index after trimming.</span>

        // Trim illegal chars from start
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">        while (sIx &lt; eIx &amp;&amp; IA[chars[sIx]] &lt; 0)</span>
<span class="fc" id="L421">            sIx++;</span>

        // Trim illegal chars from end
<span class="pc bpc" id="L424" title="1 of 4 branches missed.">        while (eIx &gt; 0 &amp;&amp; IA[chars[eIx]] &lt; 0)</span>
<span class="fc" id="L425">            eIx--;</span>

        // get the padding count (=) (0, 1 or 2)
<span class="fc bfc" id="L428" title="All 4 branches covered.">        int pad = chars[eIx] == '=' ? (chars[eIx - 1] == '=' ? 2 : 1) : 0; // Count '=' at end.</span>
<span class="fc" id="L429">        int cCnt = eIx - sIx + 1; // Content count including possible separators</span>
<span class="fc bfc" id="L430" title="All 4 branches covered.">        int sepCnt = charsLen &gt; 76 ? (chars[76] == '\r' ? cCnt / 78 : 0) &lt;&lt; 1 : 0;</span>

<span class="fc" id="L432">        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes</span>
<span class="fc" id="L433">        byte[] bytes = new byte[len]; // Preallocate byte[] of exact length</span>

        // Decode all but the last 0 - 2 bytes.
<span class="fc" id="L436">        int d = 0;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen;) {</span>
            // Assemble three bytes into an int from four &quot;valid&quot; characters.
<span class="fc" id="L439">            int i = IA[chars[sIx++]] &lt;&lt; 18 | IA[chars[sIx++]] &lt;&lt; 12 | IA[chars[sIx++]] &lt;&lt; 6 | IA[chars[sIx++]];</span>

            // Add the bytes
<span class="fc" id="L442">            bytes[d++] = (byte) (i &gt;&gt; 16);</span>
<span class="fc" id="L443">            bytes[d++] = (byte) (i &gt;&gt; 8);</span>
<span class="fc" id="L444">            bytes[d++] = (byte) i;</span>

            // If line separator, jump over it.
<span class="fc bfc" id="L447" title="All 4 branches covered.">            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {</span>
<span class="fc" id="L448">                sIx += 2;</span>
<span class="fc" id="L449">                cc = 0;</span>
            }
<span class="fc" id="L451">        }</span>

<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (d &lt; len) {</span>
            // Decode last 1-3 bytes (incl '=') into 1-3 bytes
<span class="fc" id="L455">            int i = 0;</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">            for (int j = 0; sIx &lt;= eIx - pad; j++)</span>
<span class="fc" id="L457">                i |= IA[chars[sIx++]] &lt;&lt; (18 - j * 6);</span>

<span class="fc bfc" id="L459" title="All 2 branches covered.">            for (int r = 16; d &lt; len; r -= 8)</span>
<span class="fc" id="L460">                bytes[d++] = (byte) (i &gt;&gt; r);</span>
        }

<span class="fc" id="L463">        return bytes;</span>
    }
    
    public static byte[] decodeBase64(String chars, int offset, int charsLen) {
        // Check special case
<span class="fc bfc" id="L468" title="All 2 branches covered.">        if (charsLen == 0) {</span>
<span class="fc" id="L469">            return new byte[0];</span>
        }

<span class="fc" id="L472">        int sIx = offset, eIx = offset + charsLen - 1; // Start and end index after trimming.</span>

        // Trim illegal chars from start
<span class="pc bpc" id="L475" title="1 of 4 branches missed.">        while (sIx &lt; eIx &amp;&amp; IA[chars.charAt(sIx)] &lt; 0)</span>
<span class="fc" id="L476">            sIx++;</span>

        // Trim illegal chars from end
<span class="pc bpc" id="L479" title="1 of 4 branches missed.">        while (eIx &gt; 0 &amp;&amp; IA[chars.charAt(eIx)] &lt; 0)</span>
<span class="fc" id="L480">            eIx--;</span>

        // get the padding count (=) (0, 1 or 2)
<span class="fc bfc" id="L483" title="All 4 branches covered.">        int pad = chars.charAt(eIx) == '=' ? (chars.charAt(eIx - 1) == '=' ? 2 : 1) : 0; // Count '=' at end.</span>
<span class="fc" id="L484">        int cCnt = eIx - sIx + 1; // Content count including possible separators</span>
<span class="fc bfc" id="L485" title="All 4 branches covered.">        int sepCnt = charsLen &gt; 76 ? (chars.charAt(76) == '\r' ? cCnt / 78 : 0) &lt;&lt; 1 : 0;</span>

<span class="fc" id="L487">        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes</span>
<span class="fc" id="L488">        byte[] bytes = new byte[len]; // Preallocate byte[] of exact length</span>

        // Decode all but the last 0 - 2 bytes.
<span class="fc" id="L491">        int d = 0;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen;) {</span>
            // Assemble three bytes into an int from four &quot;valid&quot; characters.
<span class="fc" id="L494">            int i = IA[chars.charAt(sIx++)] &lt;&lt; 18 | IA[chars.charAt(sIx++)] &lt;&lt; 12 | IA[chars.charAt(sIx++)] &lt;&lt; 6 | IA[chars.charAt(sIx++)];</span>

            // Add the bytes
<span class="fc" id="L497">            bytes[d++] = (byte) (i &gt;&gt; 16);</span>
<span class="fc" id="L498">            bytes[d++] = (byte) (i &gt;&gt; 8);</span>
<span class="fc" id="L499">            bytes[d++] = (byte) i;</span>

            // If line separator, jump over it.
<span class="fc bfc" id="L502" title="All 4 branches covered.">            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {</span>
<span class="fc" id="L503">                sIx += 2;</span>
<span class="fc" id="L504">                cc = 0;</span>
            }
<span class="fc" id="L506">        }</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (d &lt; len) {</span>
            // Decode last 1-3 bytes (incl '=') into 1-3 bytes
<span class="fc" id="L510">            int i = 0;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">            for (int j = 0; sIx &lt;= eIx - pad; j++)</span>
<span class="fc" id="L512">                i |= IA[chars.charAt(sIx++)] &lt;&lt; (18 - j * 6);</span>

<span class="fc bfc" id="L514" title="All 2 branches covered.">            for (int r = 16; d &lt; len; r -= 8)</span>
<span class="fc" id="L515">                bytes[d++] = (byte) (i &gt;&gt; r);</span>
        }

<span class="fc" id="L518">        return bytes;</span>
    }

    /**
     * Decodes a BASE64 encoded string that is known to be resonably well formatted. The method is about twice as fast
     * as decode(String). The preconditions are:&lt;br&gt;
     * + The array must have a line length of 76 chars OR no line separators at all (one line).&lt;br&gt;
     * + Line separator must be &quot;\r\n&quot;, as specified in RFC 2045 + The array must not contain illegal characters within
     * the encoded string&lt;br&gt;
     * + The array CAN have illegal characters at the beginning and end, those will be dealt with appropriately.&lt;br&gt;
     * 
     * @param s The source string. Length 0 will return an empty array. &lt;code&gt;null&lt;/code&gt; will throw an exception.
     * @return The decoded array of bytes. May be of length 0.
     */
    public static byte[] decodeBase64(String s) {
        // Check special case
<span class="fc" id="L534">        int sLen = s.length();</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (sLen == 0) {</span>
<span class="fc" id="L536">            return new byte[0];</span>
        }

<span class="fc" id="L539">        int sIx = 0, eIx = sLen - 1; // Start and end index after trimming.</span>

        // Trim illegal chars from start
<span class="pc bpc" id="L542" title="1 of 4 branches missed.">        while (sIx &lt; eIx &amp;&amp; IA[s.charAt(sIx) &amp; 0xff] &lt; 0)</span>
<span class="fc" id="L543">            sIx++;</span>

        // Trim illegal chars from end
<span class="pc bpc" id="L546" title="1 of 4 branches missed.">        while (eIx &gt; 0 &amp;&amp; IA[s.charAt(eIx) &amp; 0xff] &lt; 0)</span>
<span class="fc" id="L547">            eIx--;</span>

        // get the padding count (=) (0, 1 or 2)
<span class="fc bfc" id="L550" title="All 4 branches covered.">        int pad = s.charAt(eIx) == '=' ? (s.charAt(eIx - 1) == '=' ? 2 : 1) : 0; // Count '=' at end.</span>
<span class="fc" id="L551">        int cCnt = eIx - sIx + 1; // Content count including possible separators</span>
<span class="fc bfc" id="L552" title="All 4 branches covered.">        int sepCnt = sLen &gt; 76 ? (s.charAt(76) == '\r' ? cCnt / 78 : 0) &lt;&lt; 1 : 0;</span>

<span class="fc" id="L554">        int len = ((cCnt - sepCnt) * 6 &gt;&gt; 3) - pad; // The number of decoded bytes</span>
<span class="fc" id="L555">        byte[] dArr = new byte[len]; // Preallocate byte[] of exact length</span>

        // Decode all but the last 0 - 2 bytes.
<span class="fc" id="L558">        int d = 0;</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen;) {</span>
            // Assemble three bytes into an int from four &quot;valid&quot; characters.
<span class="fc" id="L561">            int i = IA[s.charAt(sIx++)] &lt;&lt; 18 | IA[s.charAt(sIx++)] &lt;&lt; 12 | IA[s.charAt(sIx++)] &lt;&lt; 6</span>
<span class="fc" id="L562">                    | IA[s.charAt(sIx++)];</span>

            // Add the bytes
<span class="fc" id="L565">            dArr[d++] = (byte) (i &gt;&gt; 16);</span>
<span class="fc" id="L566">            dArr[d++] = (byte) (i &gt;&gt; 8);</span>
<span class="fc" id="L567">            dArr[d++] = (byte) i;</span>

            // If line separator, jump over it.
<span class="fc bfc" id="L570" title="All 4 branches covered.">            if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) {</span>
<span class="fc" id="L571">                sIx += 2;</span>
<span class="fc" id="L572">                cc = 0;</span>
            }
<span class="fc" id="L574">        }</span>

<span class="fc bfc" id="L576" title="All 2 branches covered.">        if (d &lt; len) {</span>
            // Decode last 1-3 bytes (incl '=') into 1-3 bytes
<span class="fc" id="L578">            int i = 0;</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">            for (int j = 0; sIx &lt;= eIx - pad; j++)</span>
<span class="fc" id="L580">                i |= IA[s.charAt(sIx++)] &lt;&lt; (18 - j * 6);</span>

<span class="fc bfc" id="L582" title="All 2 branches covered.">            for (int r = 16; d &lt; len; r -= 8)</span>
<span class="fc" id="L583">                dArr[d++] = (byte) (i &gt;&gt; r);</span>
        }

<span class="fc" id="L586">        return dArr;</span>
    }
    
    public static int encodeUTF8(char[] chars, int offset, int len, byte[] bytes) {
<span class="fc" id="L590">        int sl = offset + len;</span>
<span class="fc" id="L591">        int dp = 0;</span>
<span class="fc" id="L592">        int dlASCII = dp + Math.min(len, bytes.length);</span>

        // ASCII only optimized loop
<span class="fc bfc" id="L595" title="All 4 branches covered.">        while (dp &lt; dlASCII &amp;&amp; chars[offset] &lt; '\u0080') {</span>
<span class="fc" id="L596">            bytes[dp++] = (byte) chars[offset++];</span>
        }

<span class="fc bfc" id="L599" title="All 2 branches covered.">        while (offset &lt; sl) {</span>
<span class="fc" id="L600">            char c = chars[offset++];</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (c &lt; 0x80) {</span>
                // Have at most seven bits
<span class="fc" id="L603">                bytes[dp++] = (byte) c;</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">            } else if (c &lt; 0x800) {</span>
                // 2 bytes, 11 bits
<span class="fc" id="L606">                bytes[dp++] = (byte) (0xc0 | (c &gt;&gt; 6));</span>
<span class="fc" id="L607">                bytes[dp++] = (byte) (0x80 | (c &amp; 0x3f));</span>
<span class="fc bfc" id="L608" title="All 4 branches covered.">            } else if (c &gt;= '\uD800' &amp;&amp; c &lt; ('\uDFFF' + 1)) { //Character.isSurrogate(c) but 1.7</span>
                final int uc;
<span class="fc" id="L610">                int ip = offset - 1;</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                if (Character.isHighSurrogate(c)) {</span>
<span class="pc bpc" id="L612" title="1 of 2 branches missed.">                    if (sl - ip &lt; 2) {</span>
<span class="nc" id="L613">                        uc = -1;</span>
                    } else {
<span class="fc" id="L615">                        char d = chars[ip + 1];</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">                        if (Character.isLowSurrogate(d)) {</span>
<span class="fc" id="L617">                            uc = Character.toCodePoint(c, d);</span>
                        } else {
<span class="nc" id="L619">                            throw new JSONException(&quot;encodeUTF8 error&quot;, new MalformedInputException(1));</span>
                        }
<span class="fc" id="L621">                    }</span>
                } else {
<span class="nc bnc" id="L623" title="All 2 branches missed.">                    if (Character.isLowSurrogate(c)) {</span>
<span class="nc" id="L624">                        throw new JSONException(&quot;encodeUTF8 error&quot;, new MalformedInputException(1));</span>
                    } else {
<span class="nc" id="L626">                        uc = c;</span>
                    }
                }
                
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                if (uc &lt; 0) {</span>
<span class="nc" id="L631">                    bytes[dp++] = (byte) '?';</span>
                } else {
<span class="fc" id="L633">                    bytes[dp++] = (byte) (0xf0 | ((uc &gt;&gt; 18)));</span>
<span class="fc" id="L634">                    bytes[dp++] = (byte) (0x80 | ((uc &gt;&gt; 12) &amp; 0x3f));</span>
<span class="fc" id="L635">                    bytes[dp++] = (byte) (0x80 | ((uc &gt;&gt; 6) &amp; 0x3f));</span>
<span class="fc" id="L636">                    bytes[dp++] = (byte) (0x80 | (uc &amp; 0x3f));</span>
<span class="fc" id="L637">                    offset++; // 2 chars</span>
                }
<span class="fc" id="L639">            } else {</span>
                // 3 bytes, 16 bits
<span class="fc" id="L641">                bytes[dp++] = (byte) (0xe0 | ((c &gt;&gt; 12)));</span>
<span class="fc" id="L642">                bytes[dp++] = (byte) (0x80 | ((c &gt;&gt; 6) &amp; 0x3f));</span>
<span class="fc" id="L643">                bytes[dp++] = (byte) (0x80 | (c &amp; 0x3f));</span>
            }
<span class="fc" id="L645">        }</span>
<span class="fc" id="L646">        return dp;</span>
    }

    /**
     * @deprecated
     */
    public static int decodeUTF8(byte[] sa, int sp, int len, char[] da) {
<span class="fc" id="L653">        final int sl = sp + len;</span>
<span class="fc" id="L654">        int dp = 0;</span>
<span class="fc" id="L655">        int dlASCII = Math.min(len, da.length);</span>

        // ASCII only optimized loop
<span class="fc bfc" id="L658" title="All 4 branches covered.">        while (dp &lt; dlASCII &amp;&amp; sa[sp] &gt;= 0)</span>
<span class="fc" id="L659">            da[dp++] = (char) sa[sp++];</span>

<span class="fc bfc" id="L661" title="All 2 branches covered.">        while (sp &lt; sl) {</span>
<span class="fc" id="L662">            int b1 = sa[sp++];</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (b1 &gt;= 0) {</span>
                // 1 byte, 7 bits: 0xxxxxxx
<span class="fc" id="L665">                da[dp++] = (char) b1;</span>
<span class="pc bpc" id="L666" title="1 of 4 branches missed.">            } else if ((b1 &gt;&gt; 5) == -2 &amp;&amp; (b1 &amp; 0x1e) != 0) {</span>
                // 2 bytes, 11 bits: 110xxxxx 10xxxxxx
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">                if (sp &lt; sl) {</span>
<span class="fc" id="L669">                    int b2 = sa[sp++];</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">                    if ((b2 &amp; 0xc0) != 0x80) { // isNotContinuation(b2)</span>
<span class="nc" id="L671">                        return -1;</span>
                    } else {
<span class="fc" id="L673">                        da[dp++] = (char) (((b1 &lt;&lt; 6) ^ b2)^</span>
                                       (((byte) 0xC0 &lt;&lt; 6) ^
                                        ((byte) 0x80 &lt;&lt; 0)));
                    }
<span class="fc" id="L677">                    continue;</span>
                }
<span class="nc" id="L679">                return -1;</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            } else if ((b1 &gt;&gt; 4) == -2) {</span>
                // 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">                if (sp + 1 &lt; sl) {</span>
<span class="fc" id="L683">                    int b2 = sa[sp++];</span>
<span class="fc" id="L684">                    int b3 = sa[sp++];</span>
<span class="pc bpc" id="L685" title="3 of 8 branches missed.">                    if ((b1 == (byte) 0xe0 &amp;&amp; (b2 &amp; 0xe0) == 0x80) //</span>
                        || (b2 &amp; 0xc0) != 0x80 //
                        || (b3 &amp; 0xc0) != 0x80) { // isMalformed3(b1, b2, b3)
<span class="nc" id="L688">                        return -1;</span>
                    } else {
<span class="fc" id="L690">                        char c = (char)((b1 &lt;&lt; 12) ^</span>
                                          (b2 &lt;&lt;  6) ^
                                          (b3 ^
                                          (((byte) 0xE0 &lt;&lt; 12) ^
                                          ((byte) 0x80 &lt;&lt;  6) ^
                                          ((byte) 0x80 &lt;&lt;  0))));
<span class="pc bpc" id="L696" title="1 of 4 branches missed.">                        boolean isSurrogate =  c &gt;= Character.MIN_SURROGATE &amp;&amp; c &lt; (Character.MAX_SURROGATE + 1);</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                        if (isSurrogate) {</span>
<span class="nc" id="L698">                            return -1;</span>
                        } else {
<span class="fc" id="L700">                            da[dp++] = c;</span>
                        }
                    }
<span class="fc" id="L703">                    continue;</span>
                }
<span class="nc" id="L705">                return -1;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">            } else if ((b1 &gt;&gt; 3) == -2) {</span>
                // 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                if (sp + 2 &lt; sl) {</span>
<span class="fc" id="L709">                    int b2 = sa[sp++];</span>
<span class="fc" id="L710">                    int b3 = sa[sp++];</span>
<span class="fc" id="L711">                    int b4 = sa[sp++];</span>
<span class="fc" id="L712">                    int uc = ((b1 &lt;&lt; 18) ^</span>
                              (b2 &lt;&lt; 12) ^
                              (b3 &lt;&lt;  6) ^
                              (b4 ^
                               (((byte) 0xF0 &lt;&lt; 18) ^
                               ((byte) 0x80 &lt;&lt; 12) ^
                               ((byte) 0x80 &lt;&lt;  6) ^
                               ((byte) 0x80 &lt;&lt;  0))));
<span class="pc bpc" id="L720" title="3 of 6 branches missed.">                    if (((b2 &amp; 0xc0) != 0x80 || (b3 &amp; 0xc0) != 0x80 || (b4 &amp; 0xc0) != 0x80) // isMalformed4</span>
                        ||
                        // shortest form check
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">                        !Character.isSupplementaryCodePoint(uc)) {</span>
<span class="nc" id="L724">                        return -1;</span>
                    } else {
<span class="fc" id="L726">                        da[dp++] =  (char) ((uc &gt;&gt;&gt; 10) + (Character.MIN_HIGH_SURROGATE - (Character.MIN_SUPPLEMENTARY_CODE_POINT &gt;&gt;&gt; 10))); // Character.highSurrogate(uc);</span>
<span class="fc" id="L727">                        da[dp++] = (char) ((uc &amp; 0x3ff) + Character.MIN_LOW_SURROGATE); // Character.lowSurrogate(uc);</span>
                    }
<span class="fc" id="L729">                    continue;</span>
                }
<span class="nc" id="L731">                return -1;</span>
            } else {
<span class="fc" id="L733">                return -1;</span>
            }
<span class="fc" id="L735">        }</span>
<span class="fc" id="L736">        return dp;</span>
    }

    /**
     * @deprecated
     */
    public static String readAll(Reader reader) {
<span class="nc" id="L743">        StringBuilder buf = new StringBuilder();</span>

        try {
<span class="nc" id="L746">            char[] chars = new char[2048];</span>
            for (;;) {
<span class="nc" id="L748">                int len = reader.read(chars, 0, chars.length);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if (len &lt; 0) {</span>
<span class="nc" id="L750">                    break;</span>
                }
<span class="nc" id="L752">                buf.append(chars, 0, len);</span>
<span class="nc" id="L753">            }</span>
<span class="nc" id="L754">        } catch(Exception ex) {</span>
<span class="nc" id="L755">            throw new JSONException(&quot;read string from reader error&quot;, ex);</span>
<span class="nc" id="L756">        }</span>

<span class="nc" id="L758">        return buf.toString();</span>
    }

    public static boolean isValidJsonpQueryParam(String value){
<span class="pc bpc" id="L762" title="1 of 4 branches missed.">        if (value == null || value.length() == 0) {</span>
<span class="fc" id="L763">            return false;</span>
        }

<span class="fc bfc" id="L766" title="All 2 branches covered.">        for (int i = 0, len = value.length(); i &lt; len; ++i) {</span>
<span class="fc" id="L767">            char ch = value.charAt(i);</span>
<span class="pc bpc" id="L768" title="1 of 4 branches missed.">            if(ch != '.' &amp;&amp; !IOUtils.isIdent(ch)){</span>
<span class="fc" id="L769">                return false;</span>
            }
        }

<span class="fc" id="L773">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>