<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CombinedConfiguration.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Configuration</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.configuration2</a> &gt; <span class="el_source">CombinedConfiguration.java</span></div><h1>CombinedConfiguration.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.configuration2;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.configuration2.event.ConfigurationEvent;
import org.apache.commons.configuration2.event.EventListener;
import org.apache.commons.configuration2.event.EventSource;
import org.apache.commons.configuration2.event.EventType;
import org.apache.commons.configuration2.ex.ConfigurationRuntimeException;
import org.apache.commons.configuration2.sync.LockMode;
import org.apache.commons.configuration2.tree.DefaultConfigurationKey;
import org.apache.commons.configuration2.tree.DefaultExpressionEngine;
import org.apache.commons.configuration2.tree.ExpressionEngine;
import org.apache.commons.configuration2.tree.ImmutableNode;
import org.apache.commons.configuration2.tree.NodeCombiner;
import org.apache.commons.configuration2.tree.NodeTreeWalker;
import org.apache.commons.configuration2.tree.QueryResult;
import org.apache.commons.configuration2.tree.TreeUtils;
import org.apache.commons.configuration2.tree.UnionCombiner;

/**
 * &lt;p&gt;
 * A hierarchical composite configuration class.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This class maintains a list of configuration objects, which can be added
 * using the diverse {@code addConfiguration()} methods. After that the
 * configurations can be accessed either by name (if one was provided when the
 * configuration was added) or by index. For the whole set of managed
 * configurations a logical node structure is constructed. For this purpose a
 * {@link org.apache.commons.configuration2.tree.NodeCombiner NodeCombiner}
 * object can be set. This makes it possible to specify different algorithms for
 * the combination process.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The big advantage of this class is that it creates a truly hierarchical
 * structure of all the properties stored in the contained configurations - even
 * if some of them are no hierarchical configurations per se. So all enhanced
 * features provided by a hierarchical configuration (e.g. choosing an
 * expression engine) are applicable.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The class works by registering itself as an event listener at all added
 * configurations. So it gets notified whenever one of these configurations is
 * changed and can invalidate its internal node structure. The next time a
 * property is accessed the node structure will be re-constructed using the
 * current state of the managed configurations. Note that, depending on the used
 * {@code NodeCombiner}, this may be a complex operation.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Because of the way a {@code CombinedConfiguration} is working it has more or
 * less view character: it provides a logic view on the configurations it
 * contains. In this constellation not all methods defined for hierarchical
 * configurations - especially methods that update the stored properties - can
 * be implemented in a consistent manner. Using such methods (like
 * {@code addProperty()}, or {@code clearProperty()} on a
 * {@code CombinedConfiguration} is not strictly forbidden, however, depending
 * on the current {@link NodeCombiner} and the involved properties, the results
 * may be different than expected. Some examples may illustrate this:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Imagine a {@code CombinedConfiguration} &lt;em&gt;cc&lt;/em&gt; containing two child
 * configurations with the following content:
 * &lt;dl&gt;
 * &lt;dt&gt;user.properties&lt;/dt&gt;
 * &lt;dd&gt;
 *
 * &lt;pre&gt;
 * gui.background = blue
 * gui.position = (10, 10, 400, 200)
 * &lt;/pre&gt;
 *
 * &lt;/dd&gt;
 * &lt;dt&gt;default.properties&lt;/dt&gt;
 * &lt;dd&gt;
 *
 * &lt;pre&gt;
 * gui.background = black
 * gui.foreground = white
 * home.dir = /data
 * &lt;/pre&gt;
 *
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 * As a {@code NodeCombiner} a
 * {@link org.apache.commons.configuration2.tree.OverrideCombiner
 * OverrideCombiner} is used. This combiner will ensure that defined user
 * settings take precedence over the default values. If the resulting
 * {@code CombinedConfiguration} is queried for the background color,
 * {@code blue} will be returned because this value is defined in
 * {@code user.properties}. Now consider what happens if the key
 * {@code gui.background} is removed from the {@code CombinedConfiguration}:
 *
 * &lt;pre&gt;
 * cc.clearProperty(&amp;quot;gui.background&amp;quot;);
 * &lt;/pre&gt;
 *
 * Will a {@code cc.containsKey(&quot;gui.background&quot;)} now return &lt;b&gt;false&lt;/b&gt;? No,
 * it won't! The {@code clearProperty()} operation is executed on the node set
 * of the combined configuration, which was constructed from the nodes of the
 * two child configurations. It causes the value of the &lt;em&gt;background&lt;/em&gt; node
 * to be cleared, which is also part of the first child configuration. This
 * modification of one of its child configurations causes the
 * {@code CombinedConfiguration} to be re-constructed. This time the
 * {@code OverrideCombiner} cannot find a {@code gui.background} property in the
 * first child configuration, but it finds one in the second, and adds it to the
 * resulting combined configuration. So the property is still present (with a
 * different value now).&lt;/li&gt;
 * &lt;li&gt;{@code addProperty()} can also be problematic: Most node combiners use
 * special view nodes for linking parts of the original configurations' data
 * together. If new properties are added to such a special node, they do not
 * belong to any of the managed configurations and thus hang in the air. Using
 * the same configurations as in the last example, the statement
 *
 * &lt;pre&gt;
 * addProperty(&amp;quot;database.user&amp;quot;, &amp;quot;scott&amp;quot;);
 * &lt;/pre&gt;
 *
 * would cause such a hanging property. If now one of the child configurations
 * is changed and the {@code CombinedConfiguration} is re-constructed, this
 * property will disappear! (Add operations are not problematic if they result
 * in a child configuration being updated. For instance an
 * {@code addProperty(&quot;home.url&quot;, &quot;localhost&quot;);} will alter the second child
 * configuration - because the prefix &lt;em&gt;home&lt;/em&gt; is here already present;
 * when the {@code CombinedConfiguration} is re-constructed, this change is
 * taken into account.)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Because of such problems it is recommended to perform updates only on the
 * managed child configurations.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Whenever the node structure of a {@code CombinedConfiguration} becomes
 * invalid (either because one of the contained configurations was modified or
 * because the {@code invalidate()} method was directly called) an event is
 * generated. So this can be detected by interested event listeners. This also
 * makes it possible to add a combined configuration into another one.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Notes about thread-safety: This configuration implementation uses a
 * {@code Synchronizer} object to protect instances against concurrent access.
 * The concrete {@code Synchronizer} implementation used determines whether an
 * instance of this class is thread-safe or not. In contrast to other
 * implementations derived from {@link BaseHierarchicalConfiguration},
 * thread-safety is an issue here because the nodes structure used by this
 * configuration has to be constructed dynamically when a child configuration is
 * changed. Therefore, when multiple threads are involved which also manipulate
 * one of the child configurations, a proper {@code Synchronizer} object should
 * be set. Note that the {@code Synchronizer} objects used by the child
 * configurations do not really matter. Because immutable in-memory nodes
 * structures are used for them there is no danger that updates on child
 * configurations could interfere with read operations on the combined
 * configuration.
 * &lt;/p&gt;
 *
 * @since 1.3
 * @version $Id: CombinedConfiguration.java 1790899 2017-04-10 21:56:46Z ggregory $
 */
public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
        EventListener&lt;ConfigurationEvent&gt;, Cloneable
{
    /**
     * Constant for the event type fired when the internal node structure of a
     * combined configuration becomes invalid.
     *
     * @since 2.0
     */
<span class="nc" id="L193">    public static final EventType&lt;ConfigurationEvent&gt; COMBINED_INVALIDATE =</span>
            new EventType&lt;&gt;(ConfigurationEvent.ANY,
                    &quot;COMBINED_INVALIDATE&quot;);

    /** Constant for the expression engine for parsing the at path. */
<span class="nc" id="L198">    private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;</span>

    /** Constant for the default node combiner. */
<span class="nc" id="L201">    private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();</span>

    /** Constant for a root node for an empty configuration. */
<span class="nc" id="L204">    private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()</span>
<span class="nc" id="L205">            .create();</span>

    /** Stores the combiner. */
    private NodeCombiner nodeCombiner;

    /** Stores a list with the contained configurations. */
    private List&lt;ConfigData&gt; configurations;

    /** Stores a map with the named configurations. */
    private Map&lt;String, Configuration&gt; namedConfigurations;

    /**
     * An expression engine used for converting child configurations to
     * hierarchical ones.
     */
    private ExpressionEngine conversionExpressionEngine;

    /** A flag whether this configuration is up-to-date. */
    private boolean upToDate;

    /**
     * Creates a new instance of {@code CombinedConfiguration} and
     * initializes the combiner to be used.
     *
     * @param comb the node combiner (can be &lt;b&gt;null&lt;/b&gt;, then a union combiner
     * is used as default)
     */
    public CombinedConfiguration(NodeCombiner comb)
<span class="nc" id="L233">    {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;</span>
<span class="nc" id="L235">        initChildCollections();</span>
<span class="nc" id="L236">    }</span>

    /**
     * Creates a new instance of {@code CombinedConfiguration} that uses
     * a union combiner.
     *
     * @see org.apache.commons.configuration2.tree.UnionCombiner
     */
    public CombinedConfiguration()
    {
<span class="nc" id="L246">        this(null);</span>
<span class="nc" id="L247">    }</span>

    /**
     * Returns the node combiner that is used for creating the combined node
     * structure.
     *
     * @return the node combiner
     */
    public NodeCombiner getNodeCombiner()
    {
<span class="nc" id="L257">        beginRead(true);</span>
        try
        {
<span class="nc" id="L260">            return nodeCombiner;</span>
        }
        finally
        {
<span class="nc" id="L264">            endRead();</span>
        }
    }

    /**
     * Sets the node combiner. This object will be used when the combined node
     * structure is to be constructed. It must not be &lt;b&gt;null&lt;/b&gt;, otherwise an
     * {@code IllegalArgumentException} exception is thrown. Changing the
     * node combiner causes an invalidation of this combined configuration, so
     * that the new combiner immediately takes effect.
     *
     * @param nodeCombiner the node combiner
     */
    public void setNodeCombiner(NodeCombiner nodeCombiner)
    {
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (nodeCombiner == null)</span>
        {
<span class="nc" id="L281">            throw new IllegalArgumentException(</span>
                    &quot;Node combiner must not be null!&quot;);
        }

<span class="nc" id="L285">        beginWrite(true);</span>
        try
        {
<span class="nc" id="L288">            this.nodeCombiner = nodeCombiner;</span>
<span class="nc" id="L289">            invalidateInternal();</span>
        }
        finally
        {
<span class="nc" id="L293">            endWrite();</span>
        }
<span class="nc" id="L295">    }</span>

    /**
     * Returns the {@code ExpressionEngine} for converting flat child
     * configurations to hierarchical ones.
     *
     * @return the conversion expression engine
     * @since 1.6
     */
    public ExpressionEngine getConversionExpressionEngine()
    {
<span class="nc" id="L306">        beginRead(true);</span>
        try
        {
<span class="nc" id="L309">            return conversionExpressionEngine;</span>
        }
        finally
        {
<span class="nc" id="L313">            endRead();</span>
        }
    }

    /**
     * Sets the {@code ExpressionEngine} for converting flat child
     * configurations to hierarchical ones. When constructing the root node for
     * this combined configuration the properties of all child configurations
     * must be combined to a single hierarchical node structure. In this
     * process, non hierarchical configurations are converted to hierarchical
     * ones first. This can be problematic if a child configuration contains
     * keys that are no compatible with the default expression engine used by
     * hierarchical configurations. Therefore it is possible to specify a
     * specific expression engine to be used for this purpose.
     *
     * @param conversionExpressionEngine the conversion expression engine
     * @see ConfigurationUtils#convertToHierarchical(Configuration, ExpressionEngine)
     * @since 1.6
     */
    public void setConversionExpressionEngine(
            ExpressionEngine conversionExpressionEngine)
    {
<span class="nc" id="L335">        beginWrite(true);</span>
        try
        {
<span class="nc" id="L338">            this.conversionExpressionEngine = conversionExpressionEngine;</span>
        }
        finally
        {
<span class="nc" id="L342">            endWrite();</span>
        }
<span class="nc" id="L344">    }</span>

    /**
     * Adds a new configuration to this combined configuration. It is possible
     * (but not mandatory) to give the new configuration a name. This name must
     * be unique, otherwise a {@code ConfigurationRuntimeException} will
     * be thrown. With the optional {@code at} argument you can specify
     * where in the resulting node structure the content of the added
     * configuration should appear. This is a string that uses dots as property
     * delimiters (independent on the current expression engine). For instance
     * if you pass in the string {@code &quot;database.tables&quot;},
     * all properties of the added configuration will occur in this branch.
     *
     * @param config the configuration to add (must not be &lt;b&gt;null&lt;/b&gt;)
     * @param name the name of this configuration (can be &lt;b&gt;null&lt;/b&gt;)
     * @param at the position of this configuration in the combined tree (can be
     * &lt;b&gt;null&lt;/b&gt;)
     */
    public void addConfiguration(Configuration config, String name,
            String at)
    {
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (config == null)</span>
        {
<span class="nc" id="L367">            throw new IllegalArgumentException(</span>
                    &quot;Added configuration must not be null!&quot;);
        }

<span class="nc" id="L371">        beginWrite(true);</span>
        try
        {
<span class="nc bnc" id="L374" title="All 4 branches missed.">            if (name != null &amp;&amp; namedConfigurations.containsKey(name))</span>
            {
<span class="nc" id="L376">                throw new ConfigurationRuntimeException(</span>
                        &quot;A configuration with the name '&quot;
                                + name
                                + &quot;' already exists in this combined configuration!&quot;);
            }

<span class="nc" id="L382">            ConfigData cd = new ConfigData(config, name, at);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (getLogger().isDebugEnabled())</span>
            {
<span class="nc" id="L385">                getLogger()</span>
<span class="nc" id="L386">                        .debug(&quot;Adding configuration &quot; + config + &quot; with name &quot;</span>
                                + name);
            }
<span class="nc" id="L389">            configurations.add(cd);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (name != null)</span>
            {
<span class="nc" id="L392">                namedConfigurations.put(name, config);</span>
            }

<span class="nc" id="L395">            invalidateInternal();</span>
        }
        finally
        {
<span class="nc" id="L399">            endWrite();</span>
        }
<span class="nc" id="L401">        registerListenerAt(config);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Adds a new configuration to this combined configuration with an optional
     * name. The new configuration's properties will be added under the root of
     * the combined node structure.
     *
     * @param config the configuration to add (must not be &lt;b&gt;null&lt;/b&gt;)
     * @param name the name of this configuration (can be &lt;b&gt;null&lt;/b&gt;)
     */
    public void addConfiguration(Configuration config, String name)
    {
<span class="nc" id="L414">        addConfiguration(config, name, null);</span>
<span class="nc" id="L415">    }</span>

    /**
     * Adds a new configuration to this combined configuration. The new
     * configuration is not given a name. Its properties will be added under the
     * root of the combined node structure.
     *
     * @param config the configuration to add (must not be &lt;b&gt;null&lt;/b&gt;)
     */
    public void addConfiguration(Configuration config)
    {
<span class="nc" id="L426">        addConfiguration(config, null, null);</span>
<span class="nc" id="L427">    }</span>

    /**
     * Returns the number of configurations that are contained in this combined
     * configuration.
     *
     * @return the number of contained configurations
     */
    public int getNumberOfConfigurations()
    {
<span class="nc" id="L437">        beginRead(true);</span>
        try
        {
<span class="nc" id="L440">            return getNumberOfConfigurationsInternal();</span>
        }
        finally
        {
<span class="nc" id="L444">            endRead();</span>
        }
    }

    /**
     * Returns the configuration at the specified index. The contained
     * configurations are numbered in the order they were added to this combined
     * configuration. The index of the first configuration is 0.
     *
     * @param index the index
     * @return the configuration at this index
     */
    public Configuration getConfiguration(int index)
    {
<span class="nc" id="L458">        beginRead(true);</span>
        try
        {
<span class="nc" id="L461">            ConfigData cd = configurations.get(index);</span>
<span class="nc" id="L462">            return cd.getConfiguration();</span>
        }
        finally
        {
<span class="nc" id="L466">            endRead();</span>
        }
    }

    /**
     * Returns the configuration with the given name. This can be &lt;b&gt;null&lt;/b&gt;
     * if no such configuration exists.
     *
     * @param name the name of the configuration
     * @return the configuration with this name
     */
    public Configuration getConfiguration(String name)
    {
<span class="nc" id="L479">        beginRead(true);</span>
        try
        {
<span class="nc" id="L482">            return namedConfigurations.get(name);</span>
        }
        finally
        {
<span class="nc" id="L486">            endRead();</span>
        }
    }

    /**
     * Returns a List of all the configurations that have been added.
     * @return A List of all the configurations.
     * @since 1.7
     */
    public List&lt;Configuration&gt; getConfigurations()
    {
<span class="nc" id="L497">        beginRead(true);</span>
        try
        {
<span class="nc" id="L500">            List&lt;Configuration&gt; list =</span>
<span class="nc" id="L501">                    new ArrayList&lt;&gt;(getNumberOfConfigurationsInternal());</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            for (ConfigData cd : configurations)</span>
            {
<span class="nc" id="L504">                list.add(cd.getConfiguration());</span>
<span class="nc" id="L505">            }</span>
<span class="nc" id="L506">            return list;</span>
        }
        finally
        {
<span class="nc" id="L510">            endRead();</span>
        }
    }

    /**
     * Returns a List of the names of all the configurations that have been
     * added in the order they were added. A NULL value will be present in
     * the list for each configuration that was added without a name.
     * @return A List of all the configuration names.
     * @since 1.7
     */
    public List&lt;String&gt; getConfigurationNameList()
    {
<span class="nc" id="L523">        beginRead(true);</span>
        try
        {
<span class="nc" id="L526">            List&lt;String&gt; list = new ArrayList&lt;&gt;(getNumberOfConfigurationsInternal());</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            for (ConfigData cd : configurations)</span>
            {
<span class="nc" id="L529">                list.add(cd.getName());</span>
<span class="nc" id="L530">            }</span>
<span class="nc" id="L531">            return list;</span>
        }
        finally
        {
<span class="nc" id="L535">            endRead();</span>
        }
    }

    /**
     * Removes the specified configuration from this combined configuration.
     *
     * @param config the configuration to be removed
     * @return a flag whether this configuration was found and could be removed
     */
    public boolean removeConfiguration(Configuration config)
    {
<span class="nc bnc" id="L547" title="All 2 branches missed.">        for (int index = 0; index &lt; getNumberOfConfigurations(); index++)</span>
        {
<span class="nc bnc" id="L549" title="All 2 branches missed.">            if (configurations.get(index).getConfiguration() == config)</span>
            {
<span class="nc" id="L551">                removeConfigurationAt(index);</span>
<span class="nc" id="L552">                return true;</span>
            }
        }

<span class="nc" id="L556">        return false;</span>
    }

    /**
     * Removes the configuration at the specified index.
     *
     * @param index the index
     * @return the removed configuration
     */
    public Configuration removeConfigurationAt(int index)
    {
<span class="nc" id="L567">        ConfigData cd = configurations.remove(index);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (cd.getName() != null)</span>
        {
<span class="nc" id="L570">            namedConfigurations.remove(cd.getName());</span>
        }
<span class="nc" id="L572">        unregisterListenerAt(cd.getConfiguration());</span>
<span class="nc" id="L573">        invalidateInternal();</span>
<span class="nc" id="L574">        return cd.getConfiguration();</span>
    }

    /**
     * Removes the configuration with the specified name.
     *
     * @param name the name of the configuration to be removed
     * @return the removed configuration (&lt;b&gt;null&lt;/b&gt; if this configuration
     * was not found)
     */
    public Configuration removeConfiguration(String name)
    {
<span class="nc" id="L586">        Configuration conf = getConfiguration(name);</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (conf != null)</span>
        {
<span class="nc" id="L589">            removeConfiguration(conf);</span>
        }
<span class="nc" id="L591">        return conf;</span>
    }

    /**
     * Returns a set with the names of all configurations contained in this
     * combined configuration. Of course here are only these configurations
     * listed, for which a name was specified when they were added.
     *
     * @return a set with the names of the contained configurations (never
     * &lt;b&gt;null&lt;/b&gt;)
     */
    public Set&lt;String&gt; getConfigurationNames()
    {
<span class="nc" id="L604">        beginRead(true);</span>
        try
        {
<span class="nc" id="L607">            return namedConfigurations.keySet();</span>
        }
        finally
        {
<span class="nc" id="L611">            endRead();</span>
        }
    }

    /**
     * Invalidates this combined configuration. This means that the next time a
     * property is accessed the combined node structure must be re-constructed.
     * Invalidation of a combined configuration also means that an event of type
     * {@code EVENT_COMBINED_INVALIDATE} is fired. Note that while other
     * events most times appear twice (once before and once after an update),
     * this event is only fired once (after update).
     */
    public void invalidate()
    {
<span class="nc" id="L625">        beginWrite(true);</span>
        try
        {
<span class="nc" id="L628">            invalidateInternal();</span>
        }
        finally
        {
<span class="nc" id="L632">            endWrite();</span>
        }
<span class="nc" id="L634">    }</span>

    /**
     * Event listener call back for configuration update events. This method is
     * called whenever one of the contained configurations was modified. It
     * invalidates this combined configuration.
     *
     * @param event the update event
     */
    @Override
    public void onEvent(ConfigurationEvent event)
    {
<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (event.isBeforeUpdate())</span>
        {
<span class="nc" id="L648">            invalidate();</span>
        }
<span class="nc" id="L650">    }</span>

    /**
     * Clears this configuration. All contained configurations will be removed.
     */
    @Override
    protected void clearInternal()
    {
<span class="nc" id="L658">        unregisterListenerAtChildren();</span>
<span class="nc" id="L659">        initChildCollections();</span>
<span class="nc" id="L660">        invalidateInternal();</span>
<span class="nc" id="L661">    }</span>

    /**
     * Returns a copy of this object. This implementation performs a deep clone,
     * i.e. all contained configurations will be cloned, too. For this to work,
     * all contained configurations must be cloneable. Registered event
     * listeners won't be cloned. The clone will use the same node combiner than
     * the original.
     *
     * @return the copied object
     */
    @Override
    public Object clone()
    {
<span class="nc" id="L675">        beginRead(false);</span>
        try
        {
<span class="nc" id="L678">            CombinedConfiguration copy = (CombinedConfiguration) super.clone();</span>
<span class="nc" id="L679">            copy.initChildCollections();</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">            for (ConfigData cd : configurations)</span>
            {
<span class="nc" id="L682">                copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd</span>
<span class="nc" id="L683">                        .getConfiguration()), cd.getName(), cd.getAt());</span>
<span class="nc" id="L684">            }</span>

<span class="nc" id="L686">            return copy;</span>
        }
        finally
        {
<span class="nc" id="L690">            endRead();</span>
        }
    }

    /**
     * Returns the configuration source, in which the specified key is defined.
     * This method will determine the configuration node that is identified by
     * the given key. The following constellations are possible:
     * &lt;ul&gt;
     * &lt;li&gt;If no node object is found for this key, &lt;b&gt;null&lt;/b&gt; is returned.&lt;/li&gt;
     * &lt;li&gt;If the key maps to multiple nodes belonging to different
     * configuration sources, a {@code IllegalArgumentException} is
     * thrown (in this case no unique source can be determined).&lt;/li&gt;
     * &lt;li&gt;If exactly one node is found for the key, the (child) configuration
     * object, to which the node belongs is determined and returned.&lt;/li&gt;
     * &lt;li&gt;For keys that have been added directly to this combined
     * configuration and that do not belong to the namespaces defined by
     * existing child configurations this configuration will be returned.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param key the key of a configuration property
     * @return the configuration, to which this property belongs or &lt;b&gt;null&lt;/b&gt;
     * if the key cannot be resolved
     * @throws IllegalArgumentException if the key maps to multiple properties
     * and the source cannot be determined, or if the key is &lt;b&gt;null&lt;/b&gt;
     * @since 1.5
     */
    public Configuration getSource(String key)
    {
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (key == null)</span>
        {
<span class="nc" id="L721">            throw new IllegalArgumentException(&quot;Key must not be null!&quot;);</span>
        }

<span class="nc" id="L724">        Set&lt;Configuration&gt; sources = getSources(key);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (sources.isEmpty())</span>
        {
<span class="nc" id="L727">            return null;</span>
        }
<span class="nc" id="L729">        Iterator&lt;Configuration&gt; iterator = sources.iterator();</span>
<span class="nc" id="L730">        Configuration source = iterator.next();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (iterator.hasNext())</span>
        {
<span class="nc" id="L733">            throw new IllegalArgumentException(&quot;The key &quot; + key</span>
                    + &quot; is defined by multiple sources!&quot;);
        }
<span class="nc" id="L736">        return source;</span>
    }

    /**
     * Returns a set with the configuration sources, in which the specified key
     * is defined. This method determines the configuration nodes that are
     * identified by the given key. It then determines the configuration sources
     * to which these nodes belong and adds them to the result set. Note the
     * following points:
     * &lt;ul&gt;
     * &lt;li&gt;If no node object is found for this key, an empty set is returned.&lt;/li&gt;
     * &lt;li&gt;For keys that have been added directly to this combined configuration
     * and that do not belong to the namespaces defined by existing child
     * configurations this combined configuration is contained in the result
     * set.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param key the key of a configuration property
     * @return a set with the configuration sources, which contain this property
     * @since 2.0
     */
    public Set&lt;Configuration&gt; getSources(String key)
    {
<span class="nc" id="L759">        beginRead(false);</span>
        try
        {
<span class="nc" id="L762">            List&lt;QueryResult&lt;ImmutableNode&gt;&gt; results = fetchNodeList(key);</span>
<span class="nc" id="L763">            Set&lt;Configuration&gt; sources = new HashSet&lt;&gt;();</span>

<span class="nc bnc" id="L765" title="All 2 branches missed.">            for (QueryResult&lt;ImmutableNode&gt; result : results)</span>
            {
<span class="nc" id="L767">                Set&lt;Configuration&gt; resultSources =</span>
<span class="nc" id="L768">                        findSourceConfigurations(result.getNode());</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (resultSources.isEmpty())</span>
                {
                    // key must be defined in combined configuration
<span class="nc" id="L772">                    sources.add(this);</span>
                }
                else
                {
<span class="nc" id="L776">                    sources.addAll(resultSources);</span>
                }
<span class="nc" id="L778">            }</span>

<span class="nc" id="L780">            return sources;</span>
        }
        finally
        {
<span class="nc" id="L784">            endRead();</span>
        }
    }

    /**
     * {@inheritDoc} This implementation checks whether a combined root node
     * is available. If not, it is constructed by requesting a write lock.
     */
    @Override
    protected void beginRead(boolean optimize)
    {
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (optimize)</span>
        {
            // just need a lock, don't construct configuration
<span class="nc" id="L798">            super.beginRead(true);</span>
<span class="nc" id="L799">            return;</span>
        }

<span class="nc" id="L802">        boolean lockObtained = false;</span>
        do
        {
<span class="nc" id="L805">            super.beginRead(false);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">            if (isUpToDate())</span>
            {
<span class="nc" id="L808">                lockObtained = true;</span>
            }
            else
            {
                // release read lock and try to obtain a write lock
<span class="nc" id="L813">                endRead();</span>
<span class="nc" id="L814">                beginWrite(false); // this constructs the root node</span>
<span class="nc" id="L815">                endWrite();</span>
            }
<span class="nc bnc" id="L817" title="All 2 branches missed.">        } while (!lockObtained);</span>
<span class="nc" id="L818">    }</span>

    /**
     * {@inheritDoc} This implementation checks whether a combined root node
     * is available. If not, it is constructed now.
     */
    @Override
    protected void beginWrite(boolean optimize)
    {
<span class="nc" id="L827">        super.beginWrite(true);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (optimize)</span>
        {
            // just need a lock, don't construct configuration
<span class="nc" id="L831">            return;</span>
        }

        try
        {
<span class="nc bnc" id="L836" title="All 2 branches missed.">            if (!isUpToDate())</span>
            {
<span class="nc" id="L838">                getSubConfigurationParentModel().replaceRoot(</span>
<span class="nc" id="L839">                        constructCombinedNode(), this);</span>
<span class="nc" id="L840">                upToDate = true;</span>
            }
        }
<span class="nc" id="L843">        catch (RuntimeException rex)</span>
        {
<span class="nc" id="L845">            endWrite();</span>
<span class="nc" id="L846">            throw rex;</span>
<span class="nc" id="L847">        }</span>
<span class="nc" id="L848">    }</span>

    /**
     * Returns a flag whether this configuration has been invalidated. This
     * means that the combined nodes structure has to be rebuilt before the
     * configuration can be accessed.
     *
     * @return a flag whether this configuration is invalid
     */
    private boolean isUpToDate()
    {
<span class="nc" id="L859">        return upToDate;</span>
    }

    /**
     * Marks this configuration as invalid. This means that the next access
     * re-creates the root node. An invalidate event is also fired. Note:
     * This implementation expects that an exclusive (write) lock is held on
     * this instance.
     */
    private void invalidateInternal()
    {
<span class="nc" id="L870">        upToDate = false;</span>
<span class="nc" id="L871">        fireEvent(COMBINED_INVALIDATE, null, null, false);</span>
<span class="nc" id="L872">    }</span>

    /**
     * Initializes internal data structures for storing information about
     * child configurations.
     */
    private void initChildCollections()
    {
<span class="nc" id="L880">        configurations = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L881">        namedConfigurations = new HashMap&lt;&gt;();</span>
<span class="nc" id="L882">    }</span>

    /**
     * Creates the root node of this combined configuration.
     *
     * @return the combined root node
     */
    private ImmutableNode constructCombinedNode()
    {
<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (getNumberOfConfigurationsInternal() &lt; 1)</span>
        {
<span class="nc bnc" id="L893" title="All 2 branches missed.">            if (getLogger().isDebugEnabled())</span>
            {
<span class="nc" id="L895">                getLogger().debug(&quot;No configurations defined for &quot; + this);</span>
            }
<span class="nc" id="L897">            return EMPTY_ROOT;</span>
        }

        else
        {
<span class="nc" id="L902">            Iterator&lt;ConfigData&gt; it = configurations.iterator();</span>
<span class="nc" id="L903">            ImmutableNode node = it.next().getTransformedRoot();</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">            while (it.hasNext())</span>
            {
<span class="nc" id="L906">                node = nodeCombiner.combine(node,</span>
<span class="nc" id="L907">                        it.next().getTransformedRoot());</span>
            }
<span class="nc bnc" id="L909" title="All 2 branches missed.">            if (getLogger().isDebugEnabled())</span>
            {
<span class="nc" id="L911">                ByteArrayOutputStream os = new ByteArrayOutputStream();</span>
<span class="nc" id="L912">                PrintStream stream = new PrintStream(os);</span>
<span class="nc" id="L913">                TreeUtils.printTree(stream, node);</span>
<span class="nc" id="L914">                getLogger().debug(os.toString());</span>
            }
<span class="nc" id="L916">            return node;</span>
        }
    }

    /**
     * Determines the configurations to which the specified node belongs. This
     * is done by inspecting the nodes structures of all child configurations.
     *
     * @param node the node
     * @return a set with the owning configurations
     */
    private Set&lt;Configuration&gt; findSourceConfigurations(ImmutableNode node)
    {
<span class="nc" id="L929">        Set&lt;Configuration&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L930">        FindNodeVisitor&lt;ImmutableNode&gt; visitor =</span>
                new FindNodeVisitor&lt;&gt;(node);

<span class="nc bnc" id="L933" title="All 2 branches missed.">        for (ConfigData cd : configurations)</span>
        {
<span class="nc" id="L935">            NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,</span>
<span class="nc" id="L936">                    getModel().getNodeHandler());</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if (visitor.isFound())</span>
            {
<span class="nc" id="L939">                result.add(cd.getConfiguration());</span>
<span class="nc" id="L940">                visitor.reset();</span>
            }
<span class="nc" id="L942">        }</span>

<span class="nc" id="L944">        return result;</span>
    }

    /**
     * Registers this combined configuration as listener at the given child
     * configuration.
     *
     * @param configuration the child configuration
     */
    private void registerListenerAt(Configuration configuration)
    {
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (configuration instanceof EventSource)</span>
        {
<span class="nc" id="L957">            ((EventSource) configuration).addEventListener(</span>
                    ConfigurationEvent.ANY, this);
        }
<span class="nc" id="L960">    }</span>

    /**
     * Removes this combined configuration as listener from the given child
     * configuration.
     *
     * @param configuration the child configuration
     */
    private void unregisterListenerAt(Configuration configuration)
    {
<span class="nc bnc" id="L970" title="All 2 branches missed.">        if (configuration instanceof EventSource)</span>
        {
<span class="nc" id="L972">            ((EventSource) configuration).removeEventListener(</span>
                    ConfigurationEvent.ANY, this);
        }
<span class="nc" id="L975">    }</span>

    /**
     * Removes this combined configuration as listener from all child
     * configurations. This method is called on a clear() operation.
     */
    private void unregisterListenerAtChildren()
    {
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (configurations != null)</span>
        {
<span class="nc bnc" id="L985" title="All 2 branches missed.">            for (ConfigData child : configurations)</span>
            {
<span class="nc" id="L987">                unregisterListenerAt(child.getConfiguration());</span>
<span class="nc" id="L988">            }</span>
        }
<span class="nc" id="L990">    }</span>

    /**
     * Returns the number of child configurations in this combined
     * configuration. The internal list of child configurations is accessed
     * without synchronization.
     *
     * @return the number of child configurations
     */
    private int getNumberOfConfigurationsInternal()
    {
<span class="nc" id="L1001">        return configurations.size();</span>
    }

    /**
     * An internal helper class for storing information about contained
     * configurations.
     */
    private class ConfigData
    {
        /** Stores a reference to the configuration. */
        private final Configuration configuration;

        /** Stores the name under which the configuration is stored. */
        private final String name;

        /** Stores the at information as path of nodes. */
        private final Collection&lt;String&gt; atPath;

        /** Stores the at string.*/
        private final String at;

        /** Stores the root node for this child configuration.*/
        private ImmutableNode rootNode;

        /**
         * Creates a new instance of {@code ConfigData} and initializes
         * it.
         *
         * @param config the configuration
         * @param n the name
         * @param at the at position
         */
        public ConfigData(Configuration config, String n, String at)
<span class="nc" id="L1034">        {</span>
<span class="nc" id="L1035">            configuration = config;</span>
<span class="nc" id="L1036">            name = n;</span>
<span class="nc" id="L1037">            atPath = parseAt(at);</span>
<span class="nc" id="L1038">            this.at = at;</span>
<span class="nc" id="L1039">        }</span>

        /**
         * Returns the stored configuration.
         *
         * @return the configuration
         */
        public Configuration getConfiguration()
        {
<span class="nc" id="L1048">            return configuration;</span>
        }

        /**
         * Returns the configuration's name.
         *
         * @return the name
         */
        public String getName()
        {
<span class="nc" id="L1058">            return name;</span>
        }

        /**
         * Returns the at position of this configuration.
         *
         * @return the at position
         */
        public String getAt()
        {
<span class="nc" id="L1068">            return at;</span>
        }

        /**
         * Returns the root node for this child configuration.
         *
         * @return the root node of this child configuration
         * @since 1.5
         */
        public ImmutableNode getRootNode()
        {
<span class="nc" id="L1079">            return rootNode;</span>
        }

        /**
         * Returns the transformed root node of the stored configuration. The
         * term &amp;quot;transformed&amp;quot; means that an eventually defined at path
         * has been applied.
         *
         * @return the transformed root node
         */
        public ImmutableNode getTransformedRoot()
        {
<span class="nc" id="L1091">            ImmutableNode configRoot = getRootNodeOfConfiguration();</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            return (atPath == null) ? configRoot : prependAtPath(configRoot);</span>
        }

        /**
         * Prepends the at path to the given node.
         *
         * @param node the root node of the represented configuration
         * @return the new root node including the at path
         */
        private ImmutableNode prependAtPath(ImmutableNode node)
        {
<span class="nc" id="L1103">            ImmutableNode.Builder pathBuilder = new ImmutableNode.Builder();</span>
<span class="nc" id="L1104">            Iterator&lt;String&gt; pathIterator = atPath.iterator();</span>
<span class="nc" id="L1105">            prependAtPathComponent(pathBuilder, pathIterator.next(),</span>
                    pathIterator, node);
<span class="nc" id="L1107">            return new ImmutableNode.Builder(1).addChild(pathBuilder.create())</span>
<span class="nc" id="L1108">                    .create();</span>
        }

        /**
         * Handles a single component of the at path. A corresponding node is
         * created and added to the hierarchical path to the original root node
         * of the configuration.
         *
         * @param builder the current node builder object
         * @param currentComponent the name of the current path component
         * @param components an iterator with all components of the at path
         * @param orgRoot the original root node of the wrapped configuration
         */
        private void prependAtPathComponent(ImmutableNode.Builder builder,
                String currentComponent, Iterator&lt;String&gt; components,
                ImmutableNode orgRoot)
        {
<span class="nc" id="L1125">            builder.name(currentComponent);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if (components.hasNext())</span>
            {
<span class="nc" id="L1128">                ImmutableNode.Builder childBuilder =</span>
                        new ImmutableNode.Builder();
<span class="nc" id="L1130">                prependAtPathComponent(childBuilder, components.next(),</span>
                        components, orgRoot);
<span class="nc" id="L1132">                builder.addChild(childBuilder.create());</span>
<span class="nc" id="L1133">            }</span>
            else
            {
<span class="nc" id="L1136">                builder.addChildren(orgRoot.getChildren());</span>
<span class="nc" id="L1137">                builder.addAttributes(orgRoot.getAttributes());</span>
<span class="nc" id="L1138">                builder.value(orgRoot.getValue());</span>
            }
<span class="nc" id="L1140">        }</span>

        /**
         * Obtains the root node of the wrapped configuration. If necessary, a
         * hierarchical representation of the configuration has to be created
         * first.
         *
         * @return the root node of the associated configuration
         */
        private ImmutableNode getRootNodeOfConfiguration()
        {
<span class="nc" id="L1151">            getConfiguration().lock(LockMode.READ);</span>
            try
            {
<span class="nc" id="L1154">                ImmutableNode root =</span>
                        ConfigurationUtils
<span class="nc" id="L1156">                                .convertToHierarchical(getConfiguration(),</span>
<span class="nc" id="L1157">                                        conversionExpressionEngine).getNodeModel()</span>
<span class="nc" id="L1158">                                .getInMemoryRepresentation();</span>
<span class="nc" id="L1159">                rootNode = root;</span>
<span class="nc" id="L1160">                return root;</span>
            }
            finally
            {
<span class="nc" id="L1164">                getConfiguration().unlock(LockMode.READ);</span>
            }
        }

        /**
         * Splits the at path into its components.
         *
         * @param at the at string
         * @return a collection with the names of the single components
         */
        private Collection&lt;String&gt; parseAt(String at)
        {
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            if (at == null)</span>
            {
<span class="nc" id="L1178">                return null;</span>
            }

<span class="nc" id="L1181">            Collection&lt;String&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1182">            DefaultConfigurationKey.KeyIterator it = new DefaultConfigurationKey(</span>
<span class="nc" id="L1183">                    AT_ENGINE, at).iterator();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">            while (it.hasNext())</span>
            {
<span class="nc" id="L1186">                result.add(it.nextKey());</span>
            }
<span class="nc" id="L1188">            return result;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>